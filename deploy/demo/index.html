<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VAM Seek - 2D Video Seek Marker</title>
    <style>
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #252526;
            --bg-tertiary: #2d2d30;
            --border-color: #3c3c3c;
            --accent: #8b5cf6;
            --highlight: #e94560;
            --text: #cccccc;
            --text-dim: #808080;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Segoe UI', 'Yu Gothic UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: calc(100vh - 32px);
        }

        /* Left Panel */
        .left-panel {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
        }

        .left-panel.collapsed {
            width: 40px;
        }

        .left-panel.collapsed .upload-area,
        .left-panel.collapsed .video-list,
        .left-panel.collapsed .panel-title {
            display: none;
        }

        .left-panel.collapsed .panel-header {
            padding: 12px 8px;
            justify-content: center;
        }

        .panel-header {
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-toggle {
            background: none;
            border: none;
            color: var(--text);
            cursor: pointer;
            font-size: 14px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .panel-toggle:hover {
            background: var(--bg-primary);
        }

        .upload-area {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .upload-dropzone {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 32px 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .upload-dropzone:hover,
        .upload-dropzone.dragover {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
        }

        .upload-icon { font-size: 40px; margin-bottom: 12px; }
        .upload-text { font-size: 13px; color: var(--text-dim); line-height: 1.6; }

        .video-list { flex: 1; overflow-y: auto; padding: 8px 0; }

        .video-item {
            padding: 10px 16px;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            border-left: 3px solid transparent;
            transition: background 0.2s;
        }

        .video-item:hover { background: var(--bg-tertiary); }
        .video-item.selected { background: var(--accent); border-left-color: var(--highlight); }
        .video-item-icon { font-size: 18px; }
        .video-item-info { flex: 1; overflow: hidden; }
        .video-item-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .video-item-duration { font-size: 11px; color: var(--text-dim); margin-top: 2px; }

        /* Main Area */
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .player-area {
            flex: 1;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .player-placeholder {
            color: var(--text-dim);
            font-size: 15px;
            text-align: center;
            line-height: 1.8;
        }

        #videoPlayer {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: none;
        }

        #videoPlayer.visible { display: block; }

        .control-bar {
            height: 48px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 16px;
        }

        .btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text);
            padding: 6px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .btn:hover { background: var(--accent); border-color: var(--accent); }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-primary { background: var(--accent); border-color: var(--accent); }

        .time-display {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
        }

        .time-current { color: var(--highlight); font-weight: bold; }

        /* Grid Panel */
        .grid-panel {
            width: 420px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
        }

        .grid-panel.collapsed {
            width: 40px;
        }

        .grid-panel.collapsed .grid-container,
        .grid-panel.collapsed .grid-settings {
            display: none;
        }

        .grid-panel.collapsed .grid-header {
            flex-direction: column;
            padding: 8px 4px;
        }

        .grid-panel.collapsed .grid-title {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            margin-top: 8px;
        }

        .grid-header {
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .grid-toggle {
            background: none;
            border: none;
            color: var(--text);
            cursor: pointer;
            font-size: 16px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .grid-toggle:hover {
            background: var(--bg-primary);
        }

        .grid-settings {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .grid-label { color: var(--text-dim); font-size: 11px; }

        .grid-select {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text);
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 3px;
            cursor: pointer;
        }

        .grid-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            background: var(--bg-primary);
        }

        .grid-scroll-wrapper {
            position: relative;
            width: 100%;
        }

        .thumbnail-grid {
            display: grid;
            gap: 2px;
            background: var(--border-color);
        }

        .grid-cell {
            aspect-ratio: 16/9;
            background: var(--bg-tertiary);
            position: relative;
            overflow: hidden;
        }

        .grid-cell img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .grid-cell img.loaded { opacity: 1; }

        .cell-loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .grid-cell.loaded .cell-loader { display: none; }

        .cell-time {
            position: absolute;
            bottom: 2px;
            right: 4px;
            background: rgba(0,0,0,0.75);
            padding: 2px 6px;
            font-size: 10px;
            border-radius: 3px;
            pointer-events: none;
        }

        /* Marker */
        .svg-marker {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 50;
            display: none;
            will-change: transform;
        }

        .svg-marker svg {
            width: 100%;
            height: 100%;
        }

        /* Info Footer (fixed at bottom of grid panel) */
        .info-footer {
            flex: 0 0 auto;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
            padding: 8px 12px;
            font-size: 12px;
            font-family: 'Consolas', monospace;
            display: none;
        }

        .info-footer.visible {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-label { color: var(--text-dim); }
        .info-value { color: var(--highlight); font-weight: bold; }

        /* Loading */
        .loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            flex-direction: column;
            gap: 16px;
        }

        .loading-overlay.visible { display: flex; }

        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        /* Status Bar */
        .status-bar {
            height: 32px;
            background: var(--accent);
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-size: 12px;
            gap: 24px;
        }

        .status-item { display: flex; align-items: center; gap: 6px; }
        .status-key {
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 3px;
            font-family: monospace;
        }

        #fileInput { display: none; }

        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: var(--bg-primary); }
        ::-webkit-scrollbar-thumb { background: var(--bg-tertiary); border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: #4a4a4a; }

        @media (max-width: 1024px) {
            .left-panel { display: none; }
            .grid-panel { width: 320px; }
        }

        @media (max-width: 768px) {
            .app-container { flex-direction: column; }
            .grid-panel { width: 100%; height: 50%; }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Left Panel -->
        <div class="left-panel" id="leftPanel">
            <div class="panel-header">
                <button class="panel-toggle" id="leftPanelToggle">‚óÄ</button>
                <span class="panel-title">Video List</span>
            </div>
            <div class="upload-area">
                <div class="upload-dropzone" id="uploadDropzone">
                    <div class="upload-icon">üìÅ</div>
                    <div class="upload-text">
                        Drop video file here<br>
                        or click to select<br>
                        <small style="color: #666">Local file only (no upload)</small>
                    </div>
                </div>
                <input type="file" id="fileInput" accept="video/*">
            </div>
            <div class="video-list" id="videoList"></div>
        </div>

        <!-- Center -->
        <div class="main-area">
            <div class="player-area" id="playerArea">
                <div class="player-placeholder" id="playerPlaceholder">
                    Select a video file<br>
                    <small>MP4, WebM, MOV supported</small><br>
                    <small style="color: #888">100% client-side processing</small>
                </div>
                <video id="videoPlayer" controls></video>
            </div>
            <div class="control-bar">
                <button type="button" class="btn" id="playBtn" disabled>‚ñ∂ Play</button>
                <div class="time-display">
                    <span class="time-current" id="currentTime">00:00.00</span>
                    <span> / </span>
                    <span id="totalTime">00:00.00</span>
                </div>
                <div style="flex:1"></div>
                <span style="font-size: 12px; color: var(--text-dim)">
                    Grid: <span id="gridSizeDisplay">--</span>
                </span>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="grid-panel" id="gridPanel">
            <div class="grid-header">
                <button type="button" class="grid-toggle" id="gridToggle" title="Toggle Grid Panel">‚óÄ</button>
                <span class="grid-title">Thumbnail Grid</span>
                <div class="grid-settings">
                    <span class="grid-label">Cols:</span>
                    <select class="grid-select" id="columnsSelect">
                        <option value="3" selected>3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                        <option value="8">8</option>
                    </select>
                    <span class="grid-label">Sec/Cell:</span>
                    <select class="grid-select" id="intervalSelect">
                        <option value="5">5s</option>
                        <option value="10" selected>10s</option>
                        <option value="15">15s</option>
                        <option value="30">30s</option>
                        <option value="60">1m</option>
                    </select>
                    <button type="button" class="btn btn-primary" id="regenerateBtn" disabled>Generate</button>
                </div>
            </div>
            <div class="grid-container" id="gridContainer">
                <div class="grid-scroll-wrapper" id="gridScrollWrapper">
                    <div class="thumbnail-grid" id="thumbnailGrid"></div>
                    <div class="svg-marker" id="svgMarker">
                        <svg viewBox="0 0 155.91 155.91">
                            <circle cx="77.95" cy="77.95" r="63.49" fill="#b7392b" stroke="#fff" stroke-miterlimit="10" stroke-width="8"/>
                            <path fill="#fff" d="M66.6,109.32c-5.24,3.39-9.52,1.05-9.52-5.18v-52.38c0-6.24,4.28-8.57,9.52-5.18l38.99,25.21c5.24,3.39,5.24,8.93,0,12.31l-38.99,25.21Z"/>
                        </svg>
                    </div>
                </div>
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <div id="loadingText">Extracting frames...</div>
                </div>
            </div>
            <div class="info-footer" id="infoFooter">
                <div class="info-item">
                    <span class="info-label">Time:</span>
                    <span class="info-value" id="overlayTime">00:00.00</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Cell:</span>
                    <span class="info-value" id="overlayCell">(0, 0)</span>
                </div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <div class="status-item"><span class="status-key">Arrow Keys</span> Move marker</div>
        <div class="status-item"><span class="status-key">Space</span> Play/Pause</div>
        <div class="status-item"><span class="status-key">Click/Drag</span> Seek</div>
        <div style="flex:1"></div>
        <div class="status-item" style="color: rgba(255,255,255,0.8)">VAM Seek - Static Demo</div>
    </div>

    <script>
        // ==================================================
        // VAM Seek - Static Version (No Server Required)
        // ==================================================

        const CONFIG = {
            columns: 3,
            secondsPerCell: 10,
            thumbWidth: 160,
            thumbHeight: 90,
            videoDuration: 0
        };

        const STATE = {
            totalRows: 0,
            totalCells: 0,
            gridWidth: 0,
            gridHeight: 0,
            cellWidth: 0,
            cellHeight: 0,
            markerX: 0,
            markerY: 0,
            targetX: 0,
            targetY: 0,
            currentCellX: 0,
            currentCellY: 0,
            isDragging: false,
            isAnimating: false,
            animationId: null,
            videos: [],
            currentVideoUrl: null,
            frameExtractorVideo: null,
            // [2025-01-13] „Çø„Çπ„ÇØ„Éô„Éº„Çπ„ÅÆ‰∏≠Êñ≠ÁÆ°ÁêÜ
            currentTaskId: 0,
            activeTaskId: null
        };

        // [2025-01-13] LRU Video Cache - ÂãïÁîªÂçò‰Ωç„Åß„Ç≠„É£„ÉÉ„Ç∑„É•ÁÆ°ÁêÜ
        class VideoFrameCache {
            constructor(maxVideos = 3, maxFramesPerVideo = 200) {
                this.caches = new Map(); // videoUrl -> { frames: Map, complete: boolean }
                this.maxVideos = maxVideos;
                this.maxFramesPerVideo = maxFramesPerVideo;
            }

            // ÂãïÁîª„Çí„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´Ë®≠ÂÆöÔºàLRUÊõ¥Êñ∞Ôºâ
            setCurrentVideo(videoUrl) {
                if (this.caches.has(videoUrl)) {
                    const cache = this.caches.get(videoUrl);
                    this.caches.delete(videoUrl);
                    this.caches.set(videoUrl, cache);
                } else {
                    if (this.caches.size >= this.maxVideos) {
                        const oldest = this.caches.keys().next().value;
                        this.caches.delete(oldest);
                    }
                    this.caches.set(videoUrl, { frames: new Map(), complete: false });
                }
            }

            // „Éï„É¨„Éº„É†ÂèñÂæó
            get(videoUrl, timestamp) {
                const cache = this.caches.get(videoUrl);
                if (cache) {
                    return cache.frames.get(timestamp.toFixed(2));
                }
                return null;
            }

            // „Éï„É¨„Éº„É†ËøΩÂä†
            put(videoUrl, timestamp, data) {
                const cache = this.caches.get(videoUrl);
                if (cache) {
                    cache.frames.set(timestamp.toFixed(2), data);
                }
            }

            // ÊäΩÂá∫ÂÆå‰∫Ü„Çí„Éû„Éº„ÇØ
            markComplete(videoUrl) {
                const cache = this.caches.get(videoUrl);
                if (cache) {
                    cache.complete = true;
                }
            }

            // „Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢Ôºà‰∏≠Êñ≠ÊôÇÔºâ
            clear(videoUrl) {
                this.caches.delete(videoUrl);
            }

            // „Éá„Éê„ÉÉ„Ç∞Áî®
            getStats() {
                const stats = [];
                this.caches.forEach((cache, url) => {
                    stats.push({ url: url.substring(0, 30), frames: cache.frames.size, complete: cache.complete });
                });
                return stats;
            }
        }

        const frameCache = new VideoFrameCache(3, 200);

        // DOM Elements
        const $ = id => document.getElementById(id);
        const elements = {
            uploadDropzone: $('uploadDropzone'),
            fileInput: $('fileInput'),
            videoList: $('videoList'),
            videoPlayer: $('videoPlayer'),
            playerPlaceholder: $('playerPlaceholder'),
            playBtn: $('playBtn'),
            currentTime: $('currentTime'),
            totalTime: $('totalTime'),
            gridSizeDisplay: $('gridSizeDisplay'),
            columnsSelect: $('columnsSelect'),
            intervalSelect: $('intervalSelect'),
            regenerateBtn: $('regenerateBtn'),
            gridContainer: $('gridContainer'),
            thumbnailGrid: $('thumbnailGrid'),
            svgMarker: $('svgMarker'),
            infoFooter: $('infoFooter'),
            overlayTime: $('overlayTime'),
            overlayCell: $('overlayCell'),
            loadingOverlay: $('loadingOverlay'),
            loadingText: $('loadingText'),
            gridPanel: $('gridPanel'),
            gridToggle: $('gridToggle'),
            leftPanel: $('leftPanel'),
            leftPanelToggle: $('leftPanelToggle')
        };

        // ==================================================
        // Grid Calculation (Client-side - No API needed)
        // ==================================================

        function calculateGridConfig(videoDuration, columns, secondsPerCell) {
            const totalCells = Math.ceil(videoDuration / secondsPerCell);
            const rows = Math.ceil(totalCells / columns);
            return { rows, columns, totalCells, secondsPerCell, videoDuration };
        }

        // ==================================================
        // File Handling (No Server Upload)
        // ==================================================

        // Ê±éÁî®ÂãïÁîªË™≠„ÅøËæº„ÅøÈñ¢Êï∞
        function loadVideo(url, name, id = null) {
            const videoData = {
                id: id || Date.now().toString(),
                name: name,
                url: url,
                duration: 0,
                columns: parseInt(elements.columnsSelect.value),
                secondsPerCell: parseInt(elements.intervalSelect.value)
            };

            const tempVideo = document.createElement('video');
            tempVideo.src = url;
            tempVideo.addEventListener('loadedmetadata', () => {
                videoData.duration = tempVideo.duration;
                STATE.videos.push(videoData);
                renderVideoList();
                selectVideo(videoData.id);
                tempVideo.remove();
            }, { once: true });
            tempVideo.addEventListener('error', () => {
                tempVideo.remove();
            }, { once: true });
            tempVideo.load();
        }

        function handleFileSelect(file) {
            if (!file || !file.type.startsWith('video/')) {
                alert('Please select a video file');
                return;
            }

            const url = URL.createObjectURL(file);
            loadVideo(url, file.name);
        }

        function renderVideoList() {
            elements.videoList.innerHTML = '';
            STATE.videos.forEach(v => {
                const item = document.createElement('div');
                item.className = 'video-item' + (STATE.currentVideoUrl === v.url ? ' selected' : '');
                item.dataset.id = v.id;

                const icon = document.createElement('span');
                icon.className = 'video-item-icon';
                icon.textContent = 'üé¨';

                const info = document.createElement('div');
                info.className = 'video-item-info';

                const name = document.createElement('div');
                name.className = 'video-item-name';
                name.textContent = v.name;

                const duration = document.createElement('div');
                duration.className = 'video-item-duration';
                duration.textContent = formatTime(v.duration);

                info.appendChild(name);
                info.appendChild(duration);
                item.appendChild(icon);
                item.appendChild(info);
                item.addEventListener('click', () => selectVideo(v.id));
                elements.videoList.appendChild(item);
            });
        }

        function selectVideo(id) {
            const video = STATE.videos.find(v => v.id === id);
            if (!video) return;

            // [2025-01-13] Ââç„ÅÆ„Çø„Çπ„ÇØ„Çí‰∏≠Êñ≠
            STATE.activeTaskId = null;

            // [2025-01-13] LRU„Ç≠„É£„ÉÉ„Ç∑„É•„ÇíË®≠ÂÆö
            frameCache.setCurrentVideo(video.url);

            // [2025-01-13] ÂãïÁîª„Åî„Å®„ÅÆË®≠ÂÆö„ÇíÂæ©ÂÖÉ
            if (video.columns) {
                elements.columnsSelect.value = video.columns;
            }
            if (video.secondsPerCell) {
                elements.intervalSelect.value = video.secondsPerCell;
            }

            STATE.currentVideoUrl = video.url;
            elements.videoPlayer.src = video.url;
            elements.videoPlayer.load();
            elements.videoPlayer.classList.add('visible');
            elements.playerPlaceholder.style.display = 'none';
            elements.playBtn.disabled = false;
            elements.regenerateBtn.disabled = false;

            elements.videoPlayer.addEventListener('loadedmetadata', () => {
                // [2025-01-13] ÂãïÁîª„ÅåÂàá„ÇäÊõø„Çè„Å£„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
                if (STATE.currentVideoUrl === video.url) {
                    CONFIG.videoDuration = elements.videoPlayer.duration;
                    elements.totalTime.textContent = formatTime(CONFIG.videoDuration);
                    generateThumbnails();
                }
            }, { once: true });

            renderVideoList();
        }

        // ==================================================
        // Thumbnail Generation (Fully Client-side)
        // ==================================================

        async function generateThumbnails() {
            if (!STATE.currentVideoUrl) return;

            // [2025-01-13] Ââç„ÅÆ„Çø„Çπ„ÇØ„Çí‰∏≠Êñ≠
            STATE.activeTaskId = null;

            CONFIG.columns = parseInt(elements.columnsSelect.value);
            CONFIG.secondsPerCell = parseInt(elements.intervalSelect.value);

            // [2025-01-13] ÁèæÂú®„ÅÆÂãïÁîª„Å´Ë®≠ÂÆö„Çí‰øùÂ≠ò
            const currentVideo = STATE.videos.find(v => v.url === STATE.currentVideoUrl);
            if (currentVideo) {
                currentVideo.columns = CONFIG.columns;
                currentVideo.secondsPerCell = CONFIG.secondsPerCell;
            }

            showLoading('Generating grid...');

            const config = calculateGridConfig(
                CONFIG.videoDuration,
                CONFIG.columns,
                CONFIG.secondsPerCell
            );

            STATE.totalRows = config.rows;
            STATE.totalCells = config.totalCells;

            elements.gridSizeDisplay.textContent = `${CONFIG.columns}x${STATE.totalRows}`;

            renderGrid();
            hideLoading();

            requestAnimationFrame(() => {
                updateGridDimensions();
                initializeMarker();
                elements.infoFooter.classList.add('visible');
                extractAllFrames();
            });
        }

        function renderGrid() {
            const grid = elements.thumbnailGrid;
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${CONFIG.columns}, 1fr)`;

            for (let i = 0; i < STATE.totalCells; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.index = i;

                const loader = document.createElement('div');
                loader.className = 'cell-loader';
                cell.appendChild(loader);

                const time = i * CONFIG.secondsPerCell;
                const label = document.createElement('span');
                label.className = 'cell-time';
                label.textContent = formatTimeShort(time);
                cell.appendChild(label);

                grid.appendChild(cell);
            }
        }

        // ==================================================
        // Frame Extraction
        // ==================================================

        async function extractAllFrames() {
            if (!STATE.currentVideoUrl) return;

            // [2025-01-13] Êñ∞„Åó„ÅÑ„Çø„Çπ„ÇØID„ÇíÁô∫Ë°å
            const taskId = ++STATE.currentTaskId;
            STATE.activeTaskId = taskId;
            const targetVideoUrl = STATE.currentVideoUrl;

            // „Çø„Çπ„ÇØ„ÅåÊúâÂäπ„Åã„ÉÅ„Çß„ÉÉ„ÇØ„Åô„Çã„Éò„É´„Éë„Éº
            const isTaskValid = () => STATE.activeTaskId === taskId && STATE.currentVideoUrl === targetVideoUrl;

            try {
                // Ââç„ÅÆÂãïÁîªË¶ÅÁ¥†„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
                if (STATE.frameExtractorVideo) {
                    STATE.frameExtractorVideo.pause();
                    STATE.frameExtractorVideo.src = '';
                    STATE.frameExtractorVideo.remove();
                    STATE.frameExtractorVideo = null;
                }

                // „Çø„Çπ„ÇØ‰∏≠Êñ≠„ÉÅ„Çß„ÉÉ„ÇØ
                if (!isTaskValid()) return;

                STATE.frameExtractorVideo = await createExtractorVideo(targetVideoUrl);

                // ÂãïÁîª„É≠„Éº„ÉâÂæå„Å´ÂÜçÂ∫¶„ÉÅ„Çß„ÉÉ„ÇØ
                if (!isTaskValid() || !STATE.frameExtractorVideo) {
                    if (STATE.frameExtractorVideo) {
                        STATE.frameExtractorVideo.remove();
                        STATE.frameExtractorVideo = null;
                    }
                    return;
                }

                let extractedCount = 0;

                for (let i = 0; i < STATE.totalCells; i++) {
                    // [2025-01-13] „É´„Éº„ÉóÂÜÖ„Åß‰∏≠Êñ≠„ÉÅ„Çß„ÉÉ„ÇØÔºà„Ç≠„É£„ÉÉ„Ç∑„É•„ÅØ‰øùÊåÅÔºâ
                    if (!isTaskValid()) {
                        break;
                    }

                    // Extract thumbnail from center of cell (0.5 offset)
                    const timestamp = (i + 0.5) * CONFIG.secondsPerCell;
                    const cell = elements.thumbnailGrid.children[i];
                    if (!cell) continue;

                    // „Ç≠„É£„ÉÉ„Ç∑„É•„Åã„ÇâÂèñÂæó
                    const cached = frameCache.get(targetVideoUrl, timestamp);
                    if (cached) {
                        displayFrame(cell, cached);
                        extractedCount++;
                        continue;
                    }

                    const frame = await extractFrame(STATE.frameExtractorVideo, timestamp);

                    // ÊäΩÂá∫Âæå„Å´ÂÜçÂ∫¶„ÉÅ„Çß„ÉÉ„ÇØÔºà„Ç≠„É£„ÉÉ„Ç∑„É•„ÅØ‰øùÊåÅÔºâ
                    if (!isTaskValid()) {
                        break;
                    }

                    if (frame) {
                        frameCache.put(targetVideoUrl, timestamp, frame);
                        displayFrame(cell, frame);
                        extractedCount++;
                    }

                    await new Promise(r => setTimeout(r, 5));
                }

                // [2025-01-13] ÂÖ®„Éï„É¨„Éº„É†ÊäΩÂá∫ÂÆå‰∫ÜÊôÇ„ÅÆ„Åø„Ç≠„É£„ÉÉ„Ç∑„É•„ÇíÁ¢∫ÂÆö
                if (isTaskValid() && extractedCount === STATE.totalCells) {
                    frameCache.markComplete(targetVideoUrl);
                }

            } catch (e) {
                // Frame extraction error - silently fail
            }
        }

        function createExtractorVideo(url) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.style.display = 'none';
                video.muted = true;
                video.playsInline = true;
                video.preload = 'auto';
                // Set crossOrigin only for external URLs
                if (url.startsWith('http') && !url.startsWith(location.origin)) {
                    video.crossOrigin = 'anonymous';
                }
                video.src = url;

                const onReady = () => {
                    video.removeEventListener('loadeddata', onReady);
                    video.removeEventListener('canplay', onReady);
                    resolve(video);
                };

                video.addEventListener('loadeddata', onReady);
                video.addEventListener('canplay', onReady);
                video.addEventListener('error', reject);

                // Timeout: 10 seconds
                setTimeout(() => {
                    video.removeEventListener('loadeddata', onReady);
                    video.removeEventListener('canplay', onReady);
                    if (video.readyState >= 2) {
                        resolve(video);
                    } else {
                        reject(new Error('Video load timeout'));
                    }
                }, 10000);

                document.body.appendChild(video);
                video.load();
            });
        }

        function extractFrame(video, timestamp) {
            return new Promise(resolve => {
                // Already at the requested position
                if (Math.abs(video.currentTime - timestamp) < 0.1 && video.readyState >= 2) {
                    resolve(captureFrame(video));
                    return;
                }

                let resolved = false;

                const onSeeked = () => {
                    if (resolved) return;
                    resolved = true;
                    video.removeEventListener('seeked', onSeeked);
                    // Wait for frame to render
                    setTimeout(() => resolve(captureFrame(video)), 50);
                };

                video.addEventListener('seeked', onSeeked);
                video.currentTime = Math.min(timestamp, video.duration - 0.1);

                // Timeout: 5 seconds
                setTimeout(() => {
                    if (resolved) return;
                    resolved = true;
                    video.removeEventListener('seeked', onSeeked);
                    // Try to capture anyway
                    resolve(captureFrame(video));
                }, 5000);
            });
        }

        function captureFrame(video) {
            if (video.readyState < 2) return null;
            try {
                const canvas = document.createElement('canvas');
                canvas.width = CONFIG.thumbWidth;
                canvas.height = CONFIG.thumbHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                return canvas.toDataURL('image/jpeg', 0.8);
            } catch (e) {
                return null;
            }
        }

        function displayFrame(cell, dataUrl) {
            const loader = cell.querySelector('.cell-loader');
            if (loader) loader.remove();

            const existing = cell.querySelector('img');
            if (existing) existing.remove();

            const img = new Image();
            img.onload = () => {
                cell.insertBefore(img, cell.firstChild);
                requestAnimationFrame(() => img.classList.add('loaded'));
                cell.classList.add('loaded');
            };
            img.src = dataUrl;
        }

        // ==================================================
        // Marker
        // ==================================================

        function updateGridDimensions() {
            const grid = elements.thumbnailGrid;
            const rect = grid.getBoundingClientRect();
            STATE.gridWidth = rect.width;
            STATE.gridHeight = rect.height;

            // Get actual cell dimensions from first cell (includes gap consideration)
            const firstCell = grid.querySelector('.grid-cell');
            if (firstCell) {
                const cellRect = firstCell.getBoundingClientRect();
                STATE.cellWidth = cellRect.width;
                STATE.cellHeight = cellRect.height;

                // Calculate gap from grid computed style
                const gridStyle = getComputedStyle(grid);
                STATE.gridGap = parseFloat(gridStyle.gap) || 2;
            } else {
                STATE.cellWidth = rect.width / CONFIG.columns;
                STATE.cellHeight = rect.height / STATE.totalRows;
                STATE.gridGap = 2;
            }
        }

        function initializeMarker() {
            STATE.markerSize = Math.max(24, Math.min(STATE.cellWidth, STATE.cellHeight) * 0.42);
            elements.svgMarker.style.display = 'block';
            elements.svgMarker.style.width = `${STATE.markerSize}px`;
            elements.svgMarker.style.height = `${STATE.markerSize}px`;

            STATE.markerX = 0;
            STATE.markerY = STATE.cellHeight / 2;
            STATE.targetX = STATE.markerX;
            STATE.targetY = STATE.markerY;
            updateMarkerPosition();
        }

        function updateMarkerPosition() {
            const offsetX = STATE.markerSize / 2;
            const offsetY = STATE.markerSize / 2;
            elements.svgMarker.style.transform = `translate(${STATE.markerX - offsetX}px, ${STATE.markerY - offsetY}px)`;
        }

        function moveMarkerTo(x, y, animate = true) {
            STATE.targetX = Math.max(0, Math.min(x, STATE.gridWidth));
            STATE.targetY = Math.max(0, Math.min(y, STATE.gridHeight));

            if (animate && !STATE.isAnimating) {
                STATE.isAnimating = true;
                animateMarker();
            } else if (!animate) {
                STATE.markerX = STATE.targetX;
                STATE.markerY = STATE.targetY;
                updateMarkerPosition();
            }
        }

        function animateMarker() {
            const dx = STATE.targetX - STATE.markerX;
            const dy = STATE.targetY - STATE.markerY;

            if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) {
                STATE.markerX = STATE.targetX;
                STATE.markerY = STATE.targetY;
                STATE.isAnimating = false;
                updateMarkerPosition();
                return;
            }

            STATE.markerX += dx * 0.15;
            STATE.markerY += dy * 0.15;
            updateMarkerPosition();

            STATE.animationId = requestAnimationFrame(animateMarker);
        }

        function calculateMarkerPositionFromTime(currentTime) {
            if (STATE.totalCells === 0 || CONFIG.secondsPerCell <= 0) {
                return { x: 0, y: STATE.cellHeight / 2 };
            }

            const gap = STATE.gridGap || 2;
            const continuousCellIndex = currentTime / CONFIG.secondsPerCell;
            let row = Math.floor(continuousCellIndex / CONFIG.columns);
            row = Math.max(0, Math.min(row, STATE.totalRows - 1));

            const positionInRow = continuousCellIndex - (row * CONFIG.columns);
            const col = Math.floor(positionInRow);
            const colFraction = positionInRow - col;

            // X position: account for gap between columns
            const cellPlusGapX = STATE.cellWidth + gap;
            const x = col * cellPlusGapX + colFraction * STATE.cellWidth;

            // Y position: account for gap between rows, center in cell
            const cellPlusGapY = STATE.cellHeight + gap;
            const y = row * cellPlusGapY + STATE.cellHeight / 2;

            return {
                x: Math.max(0, Math.min(x, STATE.gridWidth)),
                y: Math.max(STATE.cellHeight / 2, Math.min(y, STATE.gridHeight - STATE.cellHeight / 2))
            };
        }

        function calculateTimeFromPosition(x, y) {
            // Account for gap between cells
            const gap = STATE.gridGap || 2;
            const cellPlusGap = STATE.cellHeight + gap;

            // Calculate row from Y (cell center corresponds to that timestamp)
            const rowContinuous = y / cellPlusGap;
            const row = Math.max(0, Math.min(Math.floor(rowContinuous), STATE.totalRows - 1));

            // Calculate column from X (account for gap)
            const cellPlusGapX = STATE.cellWidth + gap;
            const colContinuous = x / cellPlusGapX;
            const col = Math.max(0, Math.min(Math.floor(colContinuous), CONFIG.columns - 1));
            const xInCol = x - col * cellPlusGapX;
            const colFraction = Math.max(0, Math.min(xInCol / STATE.cellWidth, 1));

            // Calculate continuous cell index
            const continuousCellIndex = row * CONFIG.columns + col + colFraction;
            const timestamp = continuousCellIndex * CONFIG.secondsPerCell;

            return Math.max(0, Math.min(timestamp, CONFIG.videoDuration));
        }

        function moveToCell(col, row) {
            col = Math.max(0, col);
            row = Math.max(0, row);

            const cellIndex = row * CONFIG.columns + col;
            const lastIndex = STATE.totalCells - 1;

            if (cellIndex > lastIndex) {
                row = Math.floor(lastIndex / CONFIG.columns);
                col = lastIndex % CONFIG.columns;
            }

            STATE.currentCellX = col;
            STATE.currentCellY = row;

            const x = col * STATE.cellWidth;
            const y = (row + 0.5) * STATE.cellHeight;
            moveMarkerTo(x, y, true);

            const time = (row * CONFIG.columns + col) * CONFIG.secondsPerCell;
            elements.videoPlayer.currentTime = Math.min(time, CONFIG.videoDuration);
            updateDisplay();
            scrollToMarker();
        }

        function scrollToMarker() {
            const container = elements.gridContainer;
            const markerTop = STATE.markerY;
            const viewportHeight = container.clientHeight;
            const scrollTop = container.scrollTop;

            if (markerTop < scrollTop + 50) {
                container.scrollTo({ top: Math.max(0, markerTop - 100), behavior: 'smooth' });
            } else if (markerTop > scrollTop + viewportHeight - 50) {
                container.scrollTo({ top: markerTop - viewportHeight + 100, behavior: 'smooth' });
            }
        }

        // ==================================================
        // Display Update
        // ==================================================

        function updateDisplay() {
            const time = elements.videoPlayer.currentTime;
            elements.currentTime.textContent = formatTime(time);
            elements.overlayTime.textContent = formatTime(time);
            elements.overlayCell.textContent = `(${STATE.currentCellX}, ${STATE.currentCellY})`;
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }

        function formatTimeShort(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        function showLoading(text) {
            elements.loadingText.textContent = text;
            elements.loadingOverlay.classList.add('visible');
        }

        function hideLoading() {
            elements.loadingOverlay.classList.remove('visible');
        }

        // ==================================================
        // Events
        // ==================================================

        function setupEvents() {
            // Grid panel toggle
            elements.gridToggle.addEventListener('click', () => {
                const isCollapsed = elements.gridPanel.classList.toggle('collapsed');
                elements.gridToggle.textContent = isCollapsed ? '‚ñ∂' : '‚óÄ';
                // Recalculate grid dimensions
                if (!isCollapsed && STATE.currentVideoUrl) {
                    setTimeout(updateGridDimensions, 350);
                }
            });

            // Left panel toggle
            elements.leftPanelToggle.addEventListener('click', () => {
                const isCollapsed = elements.leftPanel.classList.toggle('collapsed');
                elements.leftPanelToggle.textContent = isCollapsed ? '‚ñ∂' : '‚óÄ';
            });

            // File selection
            elements.uploadDropzone.addEventListener('click', () => elements.fileInput.click());
            elements.fileInput.addEventListener('change', e => {
                if (e.target.files[0]) handleFileSelect(e.target.files[0]);
            });

            // Drag & drop
            elements.uploadDropzone.addEventListener('dragover', e => {
                e.preventDefault();
                elements.uploadDropzone.classList.add('dragover');
            });
            elements.uploadDropzone.addEventListener('dragleave', () => {
                elements.uploadDropzone.classList.remove('dragover');
            });
            elements.uploadDropzone.addEventListener('drop', e => {
                e.preventDefault();
                elements.uploadDropzone.classList.remove('dragover');
                if (e.dataTransfer.files[0]) handleFileSelect(e.dataTransfer.files[0]);
            });

            // Play control
            elements.playBtn.addEventListener('click', () => {
                if (elements.videoPlayer.paused) {
                    elements.videoPlayer.play();
                    elements.playBtn.textContent = '‚è∏ Pause';
                } else {
                    elements.videoPlayer.pause();
                    elements.playBtn.textContent = '‚ñ∂ Play';
                }
            });

            // Video events
            let lastScrollTime = 0;
            elements.videoPlayer.addEventListener('timeupdate', () => {
                if (!STATE.isDragging) {
                    const pos = calculateMarkerPositionFromTime(elements.videoPlayer.currentTime);
                    moveMarkerTo(pos.x, pos.y, true);
                    updateDisplay();

                    // Auto-scroll to marker (throttled to every 500ms)
                    const now = Date.now();
                    if (now - lastScrollTime > 500) {
                        scrollToMarker();
                        lastScrollTime = now;
                    }
                }
            });

            elements.videoPlayer.addEventListener('play', () => {
                elements.playBtn.textContent = '‚è∏ Pause';
            });

            elements.videoPlayer.addEventListener('pause', () => {
                elements.playBtn.textContent = '‚ñ∂ Play';
            });

            // Grid settings
            elements.regenerateBtn.addEventListener('click', generateThumbnails);
            elements.columnsSelect.addEventListener('change', () => {
                if (STATE.currentVideoUrl) generateThumbnails();
            });
            elements.intervalSelect.addEventListener('change', () => {
                if (STATE.currentVideoUrl) generateThumbnails();
            });

            // Grid interaction
            const grid = elements.thumbnailGrid;

            grid.addEventListener('mousedown', e => {
                e.preventDefault();
                STATE.isDragging = true;
                handleGridClick(e);
            });

            document.addEventListener('mousemove', e => {
                if (STATE.isDragging) handleGridClick(e);
            });

            document.addEventListener('mouseup', () => {
                if (STATE.isDragging) {
                    STATE.isDragging = false;
                    scrollToMarker();
                }
            });

            grid.addEventListener('click', handleGridClick);

            // Keyboard
            document.addEventListener('keydown', e => {
                if (!STATE.currentVideoUrl) return;

                switch (e.key) {
                    case ' ':
                        e.preventDefault();
                        elements.playBtn.click();
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        moveToCell(STATE.currentCellX - 1, STATE.currentCellY);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        moveToCell(STATE.currentCellX + 1, STATE.currentCellY);
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        moveToCell(STATE.currentCellX, STATE.currentCellY - 1);
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        moveToCell(STATE.currentCellX, STATE.currentCellY + 1);
                        break;
                    case 'Home':
                        e.preventDefault();
                        moveToCell(0, 0);
                        break;
                    case 'End':
                        e.preventDefault();
                        const lastIdx = STATE.totalCells - 1;
                        moveToCell(lastIdx % CONFIG.columns, Math.floor(lastIdx / CONFIG.columns));
                        break;
                }
            });
        }

        function handleGridClick(e) {
            const grid = elements.thumbnailGrid;
            const rect = grid.getBoundingClientRect();

            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const clampedX = Math.max(0, Math.min(x, STATE.gridWidth));
            const clampedY = Math.max(0, Math.min(y, STATE.gridHeight));

            moveMarkerTo(clampedX, clampedY, false);

            const time = calculateTimeFromPosition(clampedX, clampedY);

            // Force video frame update when paused
            const video = elements.videoPlayer;
            const wasPaused = video.paused;
            video.currentTime = time;

            // If video is paused, force frame render by briefly playing
            if (wasPaused && video.readyState >= 2) {
                video.play().then(() => {
                    video.pause();
                }).catch(() => {
                    // Ignore autoplay restrictions
                });
            }

            STATE.currentCellX = Math.floor(clampedX / STATE.cellWidth);
            STATE.currentCellY = Math.floor(clampedY / STATE.cellHeight);

            updateDisplay();
        }

        // ==================================================
        // Initialize
        // ==================================================

        setupEvents();

        // Auto-load default video
        const DEFAULT_VIDEO = 'demo.mp4';

        function loadDefaultVideo() {
            const videoData = {
                id: 'default',
                name: 'Demo Video',
                url: DEFAULT_VIDEO,
                duration: 0
            };

            const tempVideo = document.createElement('video');
            tempVideo.src = DEFAULT_VIDEO;
            tempVideo.addEventListener('loadedmetadata', () => {
                videoData.duration = tempVideo.duration;
                STATE.videos.push(videoData);
                renderVideoList();
                selectVideo(videoData.id);
            });
            tempVideo.addEventListener('error', () => {
                // Default video not found - waiting for user upload
            });
        }

        loadDefaultVideo();
    </script>
</body>
</html>
