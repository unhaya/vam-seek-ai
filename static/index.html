<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VAM Seek - 2Dã‚·ãƒ¼ã‚¯ãƒãƒ¼ã‚«ãƒ¼ ãƒ‡ãƒ¢</title>
    <style>
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #252526;
            --bg-tertiary: #2d2d30;
            --border-color: #3c3c3c;
            --accent: #8b5cf6;
            --highlight: #e94560;
            --text: #cccccc;
            --text-dim: #808080;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Segoe UI', 'Yu Gothic UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: calc(100vh - 32px);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* å·¦ãƒ‘ãƒãƒ« */
        .left-panel {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
        }

        .left-panel.collapsed {
            width: 40px;
        }

        .left-panel.collapsed .upload-area,
        .left-panel.collapsed .video-list,
        .left-panel.collapsed .panel-title {
            display: none;
        }

        .left-panel.collapsed .panel-header {
            padding: 12px 8px;
            justify-content: center;
        }

        .panel-header {
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-toggle {
            background: none;
            border: none;
            color: var(--text);
            cursor: pointer;
            font-size: 14px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .panel-toggle:hover {
            background: var(--bg-primary);
        }

        .upload-area {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .upload-dropzone {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 32px 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .upload-dropzone:hover,
        .upload-dropzone.dragover {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
        }

        .upload-icon { font-size: 40px; margin-bottom: 12px; }
        .upload-text { font-size: 13px; color: var(--text-dim); line-height: 1.6; }

        .video-list { flex: 1; overflow-y: auto; padding: 8px 0; }

        .video-item {
            padding: 10px 16px;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            border-left: 3px solid transparent;
            transition: background 0.2s;
        }

        .video-item:hover { background: var(--bg-tertiary); }
        .video-item.selected { background: var(--accent); border-left-color: var(--highlight); }
        .video-item-icon { font-size: 18px; }
        .video-item-info { flex: 1; overflow: hidden; }
        .video-item-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .video-item-duration { font-size: 11px; color: var(--text-dim); margin-top: 2px; }

        /* ä¸­å¤®ã‚¨ãƒªã‚¢ */
        .main-area {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        .player-area {
            flex: 0 0 auto;
            height: 50%;
            min-height: 200px;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .grid-area {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
            border-top: 1px solid var(--border-color);
        }

        .player-placeholder {
            color: var(--text-dim);
            font-size: 15px;
            text-align: center;
            line-height: 1.8;
        }

        #videoPlayer {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: none;
        }

        #videoPlayer.visible { display: block; }

        .control-bar {
            height: 48px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 16px;
        }

        .btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text);
            padding: 6px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .btn:hover { background: var(--accent); border-color: var(--accent); }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-primary { background: var(--accent); border-color: var(--accent); }

        .time-display {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
        }

        .time-current { color: var(--highlight); font-weight: bold; }

        /* ã‚°ãƒªãƒƒãƒ‰ãƒ‘ãƒãƒ«ï¼ˆå‹•ç”»ã®ä¸‹ã«è¡¨ç¤ºï¼‰ */
        .grid-panel {
            flex: 1;
            background: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            min-height: 0;
            transition: flex 0.3s ease, min-height 0.3s ease;
        }

        .grid-panel.collapsed {
            flex: 0 0 40px;
            min-height: 40px;
        }

        .grid-panel.collapsed .grid-container {
            display: none;
        }

        .grid-panel.collapsed .grid-settings {
            display: none;
        }

        .grid-toggle {
            background: none;
            border: none;
            color: var(--text);
            cursor: pointer;
            font-size: 14px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .grid-toggle:hover {
            background: var(--bg-primary);
        }

        .grid-header {
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .grid-settings {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .grid-label { color: var(--text-dim); font-size: 11px; }

        .grid-select {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text);
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 3px;
            cursor: pointer;
        }

        .grid-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            background: var(--bg-primary);
        }

        .grid-scroll-wrapper {
            position: relative;
            width: 100%;
        }

        .thumbnail-grid {
            display: grid;
            gap: 2px;
            background: var(--border-color);
        }

        .grid-cell {
            aspect-ratio: 16/9;
            background: var(--bg-tertiary);
            position: relative;
            overflow: hidden;
        }

        .grid-cell img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .grid-cell img.loaded { opacity: 1; }

        .cell-loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .grid-cell.loaded .cell-loader { display: none; }

        .cell-time {
            position: absolute;
            bottom: 2px;
            right: 4px;
            background: rgba(0,0,0,0.75);
            padding: 2px 6px;
            font-size: 10px;
            border-radius: 3px;
            pointer-events: none;
        }

        /* ãƒãƒ¼ã‚«ãƒ¼ */
        .svg-marker {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 50;
            display: none;
            will-change: transform;
        }

        .svg-marker svg {
            width: 100%;
            height: 100%;
        }

        /* æƒ…å ±ãƒ•ãƒƒã‚¿ãƒ¼ï¼ˆã‚°ãƒªãƒƒãƒ‰ãƒ‘ãƒãƒ«ä¸‹éƒ¨å›ºå®šï¼‰ */
        .info-footer {
            flex: 0 0 auto;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
            padding: 8px 12px;
            font-size: 12px;
            font-family: 'Consolas', monospace;
            display: none;
        }

        .info-footer.visible {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-label { color: var(--text-dim); }
        .info-value { color: var(--highlight); font-weight: bold; }

        /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° */
        .loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            flex-direction: column;
            gap: 16px;
        }

        .loading-overlay.visible { display: flex; }

        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ */
        .status-bar {
            height: 32px;
            background: var(--accent);
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-size: 12px;
            gap: 24px;
        }

        .status-item { display: flex; align-items: center; gap: 6px; }
        .status-key {
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 3px;
            font-family: monospace;
        }

        #fileInput { display: none; }

        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: var(--bg-primary); }
        ::-webkit-scrollbar-thumb { background: var(--bg-tertiary); border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: #4a4a4a; }

        /* Tablet - å·¦ãƒ‘ãƒãƒ«éè¡¨ç¤º */
        @media (max-width: 1024px) {
            .left-panel { display: none; }
        }

        /* Mobile - ç¸¦ä¸¦ã³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        @media (max-width: 768px) {
            body {
                height: 100vh;
                overflow: hidden;
            }
            .app-container {
                flex-direction: column;
                height: calc(100vh - 40px);
            }
            .main-area {
                flex: 1;
                display: flex;
                flex-direction: column;
                min-height: 0;
            }
            /* å‹•ç”»ã‚¨ãƒªã‚¢ä¸Šéƒ¨å›ºå®š */
            .player-area {
                flex: 0 0 auto;
                height: 35vh;
                min-height: 180px;
                max-height: 280px;
            }
            .control-bar {
                flex: 0 0 auto;
                flex-wrap: wrap;
                height: auto;
                padding: 6px 10px;
                gap: 6px;
            }
            /* ã‚°ãƒªãƒƒãƒ‰ã‚¨ãƒªã‚¢ãŒã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« */
            .grid-panel {
                flex: 1;
                min-height: 0;
                overflow: hidden;
            }
            .grid-container {
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            .grid-header {
                flex: 0 0 auto;
                flex-wrap: wrap;
                gap: 6px;
                padding: 6px 10px;
            }
            .grid-settings {
                width: 100%;
                justify-content: space-between;
            }
            .status-bar {
                height: 40px;
                padding: 0 10px;
                gap: 12px;
            }
        }

        /* Mobile Portrait - ã•ã‚‰ã«å°ã•ã„ç”»é¢ */
        @media (max-width: 480px) {
            .player-area {
                height: 30vh;
                min-height: 160px;
                max-height: 220px;
            }
            .grid-header {
                font-size: 11px;
            }
            .grid-settings {
                gap: 4px;
            }
            .grid-select {
                padding: 4px 6px;
                font-size: 11px;
            }
            .grid-label {
                font-size: 10px;
            }
            .btn {
                padding: 5px 8px;
                font-size: 11px;
            }
            .time-display {
                font-size: 11px;
            }
            .status-bar {
                font-size: 10px;
                height: 36px;
            }
            .status-key {
                padding: 2px 4px;
                font-size: 9px;
            }
            .cell-time {
                font-size: 8px;
                padding: 1px 3px;
            }
            .info-footer {
                font-size: 10px;
                padding: 6px 10px;
            }
        }

        /* ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹æœ€é©åŒ– */
        @media (hover: none) and (pointer: coarse) {
            .grid-cell {
                min-height: 50px;
            }
            .btn {
                min-height: 40px;
                min-width: 40px;
            }
            .grid-select {
                min-height: 32px;
            }
            .upload-dropzone {
                padding: 20px 12px;
            }
            /* ã‚¹ãƒ ãƒ¼ã‚ºã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« */
            .grid-container {
                scroll-behavior: smooth;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- å·¦ãƒ‘ãƒãƒ« -->
        <div class="left-panel" id="leftPanel">
            <div class="panel-header">
                <button type="button" class="panel-toggle" id="leftPanelToggle" title="ãƒ‘ãƒãƒ«ã‚’æŠ˜ã‚ŠãŸãŸã‚€">â—€</button>
                <span class="panel-title">å‹•ç”»ä¸€è¦§</span>
            </div>
            <div class="upload-area">
                <div class="upload-dropzone" id="uploadDropzone">
                    <div class="upload-icon">ğŸ“</div>
                    <div class="upload-text">
                        å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—<br>
                        ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ<br>
                        <small style="color: #666">â€»ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç›´æ¥èª­ã¿è¾¼ã¿ï¼ˆã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸è¦ï¼‰</small>
                    </div>
                </div>
                <input type="file" id="fileInput" accept="video/*">
            </div>
            <div class="video-list" id="videoList"></div>
        </div>

        <!-- ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆå‹•ç”» + ã‚°ãƒªãƒƒãƒ‰ç¸¦ä¸¦ã³ï¼‰ -->
        <div class="main-area">
            <!-- å‹•ç”»ã‚¨ãƒªã‚¢ -->
            <div class="player-area" id="playerArea">
                <div class="player-placeholder" id="playerPlaceholder">
                    å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„<br>
                    <small>MP4, WebM, MOV å¯¾å¿œ</small><br>
                    <small style="color: #888">â€»å®Œå…¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå‡¦ç†ï¼ˆã‚µãƒ¼ãƒãƒ¼ã¸ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãªã—ï¼‰</small>
                </div>
                <video id="videoPlayer" controls playsinline></video>
            </div>
            <div class="control-bar">
                <button type="button" class="btn" id="playBtn" disabled>â–¶ å†ç”Ÿ</button>
                <div class="time-display">
                    <span class="time-current" id="currentTime">00:00.00</span>
                    <span> / </span>
                    <span id="totalTime">00:00.00</span>
                </div>
                <div style="flex:1"></div>
                <span style="font-size: 12px; color: var(--text-dim)">
                    ã‚°ãƒªãƒƒãƒ‰: <span id="gridSizeDisplay">--</span>
                </span>
            </div>

            <!-- ã‚°ãƒªãƒƒãƒ‰ã‚¨ãƒªã‚¢ï¼ˆå‹•ç”»ã®ä¸‹ï¼‰ -->
            <div class="grid-panel" id="gridPanel">
            <div class="grid-header">
                <button type="button" class="grid-toggle" id="gridToggle" title="ã‚°ãƒªãƒƒãƒ‰ã‚’æŠ˜ã‚ŠãŸãŸã‚€">â–¼</button>
                <span class="grid-title">ã‚µãƒ ãƒã‚¤ãƒ«ã‚°ãƒªãƒƒãƒ‰</span>
                <div class="grid-settings">
                    <span class="grid-label">åˆ—:</span>
                    <select class="grid-select" id="columnsSelect">
                        <option value="3" selected>3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                        <option value="8">8</option>
                    </select>
                    <span class="grid-label">ç§’/ã‚»ãƒ«:</span>
                    <select class="grid-select" id="intervalSelect">
                        <option value="5" selected>5s</option>
                        <option value="10">10s</option>
                        <option value="15">15s</option>
                        <option value="30">30s</option>
                        <option value="60">1m</option>
                    </select>
                    <button type="button" class="btn btn-primary" id="regenerateBtn" disabled>ç”Ÿæˆ</button>
                </div>
            </div>
            <div class="grid-container" id="gridContainer">
                <div class="grid-scroll-wrapper" id="gridScrollWrapper">
                    <div class="thumbnail-grid" id="thumbnailGrid"></div>
                    <div class="svg-marker" id="svgMarker">
                        <svg viewBox="0 0 155.91 155.91">
                            <circle cx="77.95" cy="77.95" r="63.49" fill="#b7392b" stroke="#fff" stroke-miterlimit="10" stroke-width="8"/>
                            <path fill="#fff" d="M66.6,109.32c-5.24,3.39-9.52,1.05-9.52-5.18v-52.38c0-6.24,4.28-8.57,9.52-5.18l38.99,25.21c5.24,3.39,5.24,8.93,0,12.31l-38.99,25.21Z"/>
                        </svg>
                    </div>
                </div>
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <div id="loadingText">ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡ºä¸­...</div>
                </div>
            </div>
            <div class="info-footer" id="infoFooter">
                <div class="info-item">
                    <span class="info-label">æ™‚é–“:</span>
                    <span class="info-value" id="overlayTime">00:00.00</span>
                </div>
                <div class="info-item">
                    <span class="info-label">ã‚»ãƒ«:</span>
                    <span class="info-value" id="overlayCell">(0, 0)</span>
                </div>
            </div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <div class="status-item"><span class="status-key">ã‚¿ãƒƒãƒ/ãƒ‰ãƒ©ãƒƒã‚°</span> ã‚·ãƒ¼ã‚¯</div>
        <div class="status-item"><span class="status-key">â†‘â†“â†â†’</span> ãƒãƒ¼ã‚«ãƒ¼ç§»å‹•</div>
        <div style="flex:1"></div>
        <div class="status-item" style="color: rgba(255,255,255,0.8)">2D Seek Bar</div>
    </div>

    <script>
        // ==================================================
        // VAM Seek - Static Demo (No Server Required)
        // ==================================================

        // Configuration
        const CONFIG = {
            columns: 3,
            secondsPerCell: 5,
            thumbWidth: 160,
            thumbHeight: 90,
            videoDuration: 0
        };

        // State
        const STATE = {
            totalRows: 0,
            totalCells: 0,
            gridWidth: 0,
            gridHeight: 0,
            cellWidth: 0,
            cellHeight: 0,
            markerX: 0,
            markerY: 0,
            targetX: 0,
            targetY: 0,
            currentCellX: 0,
            currentCellY: 0,
            isDragging: false,
            isAnimating: false,
            animationId: null,
            videos: [],
            currentVideoUrl: null,
            frameExtractorVideo: null,
            isExtracting: false,
            aborted: false,
            pendingMetadataHandler: null, // [2025-01-13] loadedmetadataãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®å‚ç…§ã‚’ä¿æŒ
            isGenerating: false, // [2025-01-13] generateThumbnails()ã®äºŒé‡å®Ÿè¡Œé˜²æ­¢ãƒ•ãƒ©ã‚°
            generationAborted: false // [2025-01-13] ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆå‡¦ç†ã®ä¸­æ–­ãƒ•ãƒ©ã‚°
        };

        // LRU Cache (Video-aware)
        // [2025-01-13] å‹•ç”»å˜ä½ã§ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç† + LRUæ–¹å¼ã§æœ€å¤§Næœ¬ã®å‹•ç”»ã‚’ä¿æŒ
        class FrameCache {
            constructor(maxFramesPerVideo = 200, maxVideos = 3) {
                this.caches = new Map(); // videoUrl -> Map(timestamp -> dataUrl)
                this.maxFramesPerVideo = maxFramesPerVideo;
                this.maxVideos = maxVideos;
                this.currentVideoUrl = null;
            }

            /**
             * ç¾åœ¨ã®å‹•ç”»ã‚’è¨­å®šï¼ˆå‹•ç”»åˆ‡ã‚Šæ›¿ãˆæ™‚ã«å‘¼ã¶ï¼‰
             * LRUæ–¹å¼: æ—¢å­˜å‹•ç”»ãªã‚‰æœ€æ–°ã«ç§»å‹•ã€æ–°è¦å‹•ç”»ãªã‚‰å¤ã„å‹•ç”»ã‚’å‰Šé™¤
             */
            setCurrentVideo(videoUrl) {
                if (!videoUrl) return;

                const videoShortName = videoUrl.substring(videoUrl.lastIndexOf('/') + 1, videoUrl.lastIndexOf('/') + 20);

                this.currentVideoUrl = videoUrl;

                // æ—¢å­˜ã®å‹•ç”»ãªã‚‰æœ€æ–°ã«ç§»å‹•ï¼ˆLRUï¼‰
                if (this.caches.has(videoUrl)) {
                    const cache = this.caches.get(videoUrl);
                    this.caches.delete(videoUrl);
                    this.caches.set(videoUrl, cache);
                    console.log(`[FrameCache] å‹•ç”»åˆ‡ã‚Šæ›¿ãˆ (æ—¢å­˜): ${videoShortName}... (${cache.size}ãƒ•ãƒ¬ãƒ¼ãƒ ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ¸ˆã¿)`);
                    return;
                }

                // æ–°è¦å‹•ç”»: ä¸Šé™ãƒã‚§ãƒƒã‚¯
                if (this.caches.size >= this.maxVideos) {
                    // æœ€ã‚‚å¤ã„å‹•ç”»ï¼ˆæœ€åˆã®ã‚¨ãƒ³ãƒˆãƒªï¼‰ã‚’å‰Šé™¤
                    const oldestUrl = this.caches.keys().next().value;
                    const oldestShortName = oldestUrl.substring(oldestUrl.lastIndexOf('/') + 1, oldestUrl.lastIndexOf('/') + 20);
                    this.caches.delete(oldestUrl);
                    console.log(`[FrameCache] LRUå‰Šé™¤: ${oldestShortName}...`);
                }

                // æ–°ã—ã„å‹•ç”»ç”¨ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½œæˆ
                this.caches.set(videoUrl, new Map());
                console.log(`[FrameCache] å‹•ç”»åˆ‡ã‚Šæ›¿ãˆ (æ–°è¦): ${videoShortName}... (ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ•°: ${this.caches.size}/${this.maxVideos})`);
            }

            /**
             * ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å–å¾—ï¼ˆLRUæ›´æ–°ï¼‰
             */
            get(ts) {
                if (!this.currentVideoUrl) return null;

                const cache = this.caches.get(this.currentVideoUrl);
                if (!cache) return null;

                const key = ts.toFixed(2);
                if (!cache.has(key)) return null;

                // LRU: æœ€æ–°ã«ç§»å‹•
                const value = cache.get(key);
                cache.delete(key);
                cache.set(key, value);
                return value;
            }

            /**
             * ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä¿å­˜ï¼ˆLRUã€ã‚µã‚¤ã‚ºåˆ¶é™ã‚ã‚Šï¼‰
             */
            put(ts, data) {
                if (!this.currentVideoUrl || !data) return;

                const cache = this.caches.get(this.currentVideoUrl);
                if (!cache) return;

                const key = ts.toFixed(2);

                // æ—¢å­˜ã‚­ãƒ¼ãªã‚‰å‰Šé™¤ã—ã¦æœ€æ–°ã«
                if (cache.has(key)) {
                    cache.delete(key);
                } else if (cache.size >= this.maxFramesPerVideo) {
                    // ã‚µã‚¤ã‚ºä¸Šé™: æœ€å¤ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å‰Šé™¤
                    const oldestKey = cache.keys().next().value;
                    cache.delete(oldestKey);
                }

                cache.set(key, data);
            }

            /**
             * ç¾åœ¨ã®å‹•ç”»ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
             */
            clearCurrentVideo() {
                if (this.currentVideoUrl && this.caches.has(this.currentVideoUrl)) {
                    this.caches.delete(this.currentVideoUrl);
                }
            }

            /**
             * å…¨å‹•ç”»ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
             */
            clearAll() {
                this.caches.clear();
                this.currentVideoUrl = null;
            }

            /**
             * ãƒ‡ãƒãƒƒã‚°æƒ…å ±
             */
            getStats() {
                const stats = {
                    totalVideos: this.caches.size,
                    currentVideo: this.currentVideoUrl,
                    videos: []
                };

                for (const [url, cache] of this.caches.entries()) {
                    stats.videos.push({
                        url: url.substring(0, 50) + '...',
                        frames: cache.size
                    });
                }

                return stats;
            }
        }

        const frameCache = new FrameCache(200, 3);

        // DOM Elements
        const $ = id => document.getElementById(id);
        const elements = {
            uploadDropzone: $('uploadDropzone'),
            fileInput: $('fileInput'),
            videoList: $('videoList'),
            videoPlayer: $('videoPlayer'),
            playerPlaceholder: $('playerPlaceholder'),
            playBtn: $('playBtn'),
            currentTime: $('currentTime'),
            totalTime: $('totalTime'),
            gridSizeDisplay: $('gridSizeDisplay'),
            columnsSelect: $('columnsSelect'),
            intervalSelect: $('intervalSelect'),
            regenerateBtn: $('regenerateBtn'),
            gridContainer: $('gridContainer'),
            thumbnailGrid: $('thumbnailGrid'),
            svgMarker: $('svgMarker'),
            infoFooter: $('infoFooter'),
            overlayTime: $('overlayTime'),
            overlayCell: $('overlayCell'),
            loadingOverlay: $('loadingOverlay'),
            loadingText: $('loadingText'),
            gridPanel: $('gridPanel'),
            gridToggle: $('gridToggle'),
            leftPanel: $('leftPanel'),
            leftPanelToggle: $('leftPanelToggle')
        };

        // ==================================================
        // Grid Calculation (Client-side, No Server API)
        // ==================================================

        function calculateGridConfig(videoDuration, columns, secondsPerCell) {
            const totalCells = Math.ceil(videoDuration / secondsPerCell);
            const rows = Math.ceil(totalCells / columns);
            return { rows, columns, totalCells, secondsPerCell, videoDuration };
        }

        // ==================================================
        // File Loading (No Server Upload Required)
        // ==================================================

        function handleFileSelect(file) {
            if (!file || !file.type.startsWith('video/')) {
                alert('Please select a video file');
                return;
            }

            const url = URL.createObjectURL(file);
            const videoData = {
                id: Date.now().toString(),
                name: file.name,
                url: url,
                duration: 0
            };

            // Get video duration
            const tempVideo = document.createElement('video');
            tempVideo.src = url;
            tempVideo.addEventListener('loadedmetadata', () => {
                videoData.duration = tempVideo.duration;
                STATE.videos.push(videoData);
                renderVideoList();
                selectVideo(videoData.id);
            });
        }

        function renderVideoList() {
            elements.videoList.innerHTML = '';
            STATE.videos.forEach(v => {
                const item = document.createElement('div');
                item.className = 'video-item' + (STATE.currentVideoUrl === v.url ? ' selected' : '');
                item.dataset.id = v.id;

                const icon = document.createElement('span');
                icon.className = 'video-item-icon';
                icon.textContent = 'ğŸ¬';

                const info = document.createElement('div');
                info.className = 'video-item-info';

                const name = document.createElement('div');
                name.className = 'video-item-name';
                name.textContent = v.name;

                const duration = document.createElement('div');
                duration.className = 'video-item-duration';
                duration.textContent = formatTime(v.duration);

                info.appendChild(name);
                info.appendChild(duration);
                item.appendChild(icon);
                item.appendChild(info);
                item.addEventListener('click', () => selectVideo(v.id));
                elements.videoList.appendChild(item);
            });
        }

        // [2025-01-13] å‹•ç”»åˆ‡ã‚Šæ›¿ãˆæ™‚: å‡¦ç†ä¸­æ–­ + LRUã‚­ãƒ£ãƒƒã‚·ãƒ¥æ›´æ–° + ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        function selectVideo(id) {
            const video = STATE.videos.find(v => v.id === id);
            if (!video) return;

            // æ—¢ã«åŒã˜å‹•ç”»ãŒé¸æŠã•ã‚Œã¦ã„ãŸã‚‰ä½•ã‚‚ã—ãªã„
            if (STATE.currentVideoUrl === video.url) return;

            console.log(`[selectVideo] å‹•ç”»åˆ‡ã‚Šæ›¿ãˆ: ${video.name}`);

            // é€²è¡Œä¸­ã®å…¨ã¦ã®å‡¦ç†ã‚’ä¸­æ–­
            STATE.aborted = true;
            STATE.generationAborted = true;

            // å‰å›ã®loadedmetadataãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’å‰Šé™¤ï¼ˆé‡è¦ï¼ï¼‰
            if (STATE.pendingMetadataHandler) {
                elements.videoPlayer.removeEventListener('loadedmetadata', STATE.pendingMetadataHandler);
                console.log('[selectVideo] å‰å›ã®loadedmetadataãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’å‰Šé™¤');
                STATE.pendingMetadataHandler = null;
            }

            // æ–°ã—ã„å‹•ç”»URLã‚’è¨­å®š
            STATE.currentVideoUrl = video.url;

            // FrameCacheã«ç¾åœ¨ã®å‹•ç”»ã‚’é€šçŸ¥ï¼ˆLRUæ›´æ–°ï¼‰
            frameCache.setCurrentVideo(video.url);

            // å‹•ç”»ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ›´æ–°
            elements.videoPlayer.src = video.url;
            elements.videoPlayer.classList.add('visible');
            elements.playerPlaceholder.style.display = 'none';
            elements.playBtn.disabled = false;
            elements.regenerateBtn.disabled = false;

            // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†å¾Œã«ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆé–‹å§‹
            // ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®å‚ç…§ã‚’ä¿æŒï¼ˆå¾Œã§å‰Šé™¤ã§ãã‚‹ã‚ˆã†ã«ï¼‰
            const metadataHandler = () => {
                // å‹•ç”»ãŒåˆ‡ã‚Šæ›¿ã‚ã£ã¦ã„ãªã„ã‹æœ€çµ‚ç¢ºèª
                if (STATE.currentVideoUrl === video.url) {
                    CONFIG.videoDuration = elements.videoPlayer.duration;
                    elements.totalTime.textContent = formatTime(CONFIG.videoDuration);
                    generateThumbnails();
                } else {
                    console.log('[selectVideo] loadedmetadata: å‹•ç”»ãŒæ—¢ã«åˆ‡ã‚Šæ›¿ã‚ã£ã¦ã„ã‚‹ãŸã‚ç„¡è¦–');
                }
                STATE.pendingMetadataHandler = null;
            };

            STATE.pendingMetadataHandler = metadataHandler;
            elements.videoPlayer.addEventListener('loadedmetadata', metadataHandler, { once: true });

            // å‹•ç”»ãƒªã‚¹ãƒˆã®é¸æŠçŠ¶æ…‹ã‚’æ›´æ–°
            renderVideoList();
        }

        // ==================================================
        // Thumbnail Generation (Full Client-side Processing)
        // ==================================================

        // [2025-01-13] ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆ: äºŒé‡å®Ÿè¡Œé˜²æ­¢ + å‹•ç”»åˆ‡ã‚Šæ›¿ãˆæ¤œçŸ¥
        async function generateThumbnails() {
            if (!STATE.currentVideoUrl) return;

            // ã€æ’ä»–åˆ¶å¾¡ã€‘æ—¢ã«å®Ÿè¡Œä¸­ã®å ´åˆã¯å¾…æ©Ÿ
            if (STATE.isGenerating) {
                console.log('[generateThumbnails] æ—¢ã«å®Ÿè¡Œä¸­ã®ãŸã‚å¾…æ©Ÿ...');
                let waitCount = 0;
                while (STATE.isGenerating && waitCount < 100) {
                    await new Promise(r => setTimeout(r, 10));
                    waitCount++;
                }
                if (STATE.isGenerating) {
                    console.warn('[generateThumbnails] ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: å‰å›ã®å‡¦ç†ãŒçµ‚äº†ã—ãªã„ãŸã‚ä¸­æ­¢');
                    return;
                }
            }

            // ã€æ’ä»–åˆ¶å¾¡ã€‘ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
            STATE.isGenerating = true;
            STATE.generationAborted = false;
            const targetVideoUrl = STATE.currentVideoUrl; // å‹•ç”»åˆ‡ã‚Šæ›¿ãˆæ¤œçŸ¥ç”¨

            try {
                console.log(`[generateThumbnails] ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆé–‹å§‹: ${targetVideoUrl}`);

                // ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡ºå‡¦ç†ãŒæ®‹ã£ã¦ã„ãŸã‚‰ä¸­æ–­ã—ã¦å¾…æ©Ÿ
                STATE.aborted = true;
                let waitCount = 0;
                while (STATE.isExtracting && waitCount < 50) {
                    await new Promise(r => setTimeout(r, 10));
                    waitCount++;
                }

                // å¼·åˆ¶çš„ã«ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆå¿µã®ãŸã‚ï¼‰
                if (STATE.isExtracting) {
                    console.warn('[generateThumbnails] å¼·åˆ¶çš„ã«isExtractingã‚’ãƒªã‚»ãƒƒãƒˆ');
                    STATE.isExtracting = false;
                }

                // ã€å‹•ç”»åˆ‡ã‚Šæ›¿ãˆæ¤œçŸ¥ã€‘ã“ã®æ™‚ç‚¹ã§æ—¢ã«åˆ¥ã®å‹•ç”»ã«åˆ‡ã‚Šæ›¿ã‚ã£ã¦ã„ãŸã‚‰ä¸­æ­¢
                if (STATE.generationAborted || STATE.currentVideoUrl !== targetVideoUrl) {
                    console.log('[generateThumbnails] å‹•ç”»ãŒåˆ‡ã‚Šæ›¿ã‚ã£ãŸãŸã‚ä¸­æ­¢');
                    return;
                }

                // ã‚°ãƒªãƒƒãƒ‰è¨­å®šã‚’å–å¾—
                CONFIG.columns = parseInt(elements.columnsSelect.value);
                CONFIG.secondsPerCell = parseInt(elements.intervalSelect.value);

                showLoading('ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆä¸­...');

                const config = calculateGridConfig(
                    CONFIG.videoDuration,
                    CONFIG.columns,
                    CONFIG.secondsPerCell
                );

                STATE.totalRows = config.rows;
                STATE.totalCells = config.totalCells;

                elements.gridSizeDisplay.textContent = `${CONFIG.columns}Ã—${STATE.totalRows}`;

                // ã€å‹•ç”»åˆ‡ã‚Šæ›¿ãˆæ¤œçŸ¥ã€‘ã‚°ãƒªãƒƒãƒ‰è¨­å®šè¨ˆç®—å¾Œã‚‚ãƒã‚§ãƒƒã‚¯
                if (STATE.generationAborted || STATE.currentVideoUrl !== targetVideoUrl) {
                    console.log('[generateThumbnails] ã‚°ãƒªãƒƒãƒ‰è¨ˆç®—ä¸­ã«å‹•ç”»ãŒåˆ‡ã‚Šæ›¿ã‚ã£ãŸãŸã‚ä¸­æ­¢');
                    hideLoading();
                    return;
                }

                // ã‚°ãƒªãƒƒãƒ‰ã‚’å†ç”Ÿæˆ
                renderGrid();
                hideLoading();

                // ã€å‹•ç”»åˆ‡ã‚Šæ›¿ãˆæ¤œçŸ¥ã€‘ã‚°ãƒªãƒƒãƒ‰æç”»å¾Œã‚‚ãƒã‚§ãƒƒã‚¯
                if (STATE.generationAborted || STATE.currentVideoUrl !== targetVideoUrl) {
                    console.log('[generateThumbnails] ã‚°ãƒªãƒƒãƒ‰æç”»ä¸­ã«å‹•ç”»ãŒåˆ‡ã‚Šæ›¿ã‚ã£ãŸãŸã‚ä¸­æ­¢');
                    return;
                }

                // ãƒãƒ¼ã‚«ãƒ¼åˆæœŸåŒ–ã¨ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡ºé–‹å§‹
                requestAnimationFrame(() => {
                    // ã€å‹•ç”»åˆ‡ã‚Šæ›¿ãˆæ¤œçŸ¥ã€‘æœ€çµ‚ãƒã‚§ãƒƒã‚¯
                    if (STATE.generationAborted || STATE.currentVideoUrl !== targetVideoUrl) {
                        console.log('[generateThumbnails] ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡ºé–‹å§‹å‰ã«å‹•ç”»ãŒåˆ‡ã‚Šæ›¿ã‚ã£ãŸãŸã‚ä¸­æ­¢');
                        return;
                    }

                    updateGridDimensions();
                    initializeMarker();
                    elements.infoFooter.classList.add('visible');
                    extractAllFrames();
                });

                console.log('[generateThumbnails] ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆå®Œäº†');

            } finally {
                // ã€æ’ä»–åˆ¶å¾¡ã€‘å¿…ãšãƒ•ãƒ©ã‚°ã‚’è§£æ”¾
                STATE.isGenerating = false;
                console.log('[generateThumbnails] isGeneratingãƒ•ãƒ©ã‚°è§£æ”¾');
            }
        }

        function renderGrid() {
            const grid = elements.thumbnailGrid;
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${CONFIG.columns}, 1fr)`;

            for (let i = 0; i < STATE.totalCells; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.index = i;

                const loader = document.createElement('div');
                loader.className = 'cell-loader';
                cell.appendChild(loader);

                const time = i * CONFIG.secondsPerCell;
                const label = document.createElement('span');
                label.className = 'cell-time';
                label.textContent = formatTimeShort(time);
                cell.appendChild(label);

                grid.appendChild(cell);
            }
        }

        // ==================================================
        // Frame Extraction
        // ==================================================

        // [2025-01-13] å‹•ç”»URLå˜ä½ã§å‡¦ç†ã‚’ç®¡ç†ã—ã€å‹•ç”»åˆ‡ã‚Šæ›¿ãˆæ™‚ã«ç¢ºå®Ÿã«ä¸­æ–­
        async function extractAllFrames() {
            if (!STATE.currentVideoUrl) return;

            // æ—¢ã«å‡¦ç†ä¸­ãªã‚‰ä½•ã‚‚ã—ãªã„ï¼ˆç«¶åˆé˜²æ­¢ï¼‰
            if (STATE.isExtracting) return;

            STATE.isExtracting = true;
            STATE.aborted = false;

            // ã“ã®å‡¦ç†ãŒå¯¾è±¡ã¨ã™ã‚‹å‹•ç”»URLã‚’è¨˜æ†¶ï¼ˆå‡¦ç†ä¸­ã«åˆ‡ã‚Šæ›¿ã‚ã£ãŸã‹æ¤œå‡ºã™ã‚‹ãŸã‚ï¼‰
            const targetVideoUrl = STATE.currentVideoUrl;
            console.log(`[extractAllFrames] é–‹å§‹: ${STATE.totalCells}ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡º`);

            try {
                // å¤ã„æŠ½å‡ºç”¨videoè¦ç´ ã‚’å‰Šé™¤
                if (STATE.frameExtractorVideo) {
                    STATE.frameExtractorVideo.remove();
                    STATE.frameExtractorVideo = null;
                }

                // æ–°ã—ã„æŠ½å‡ºç”¨videoè¦ç´ ã‚’ä½œæˆ
                STATE.frameExtractorVideo = await createExtractorVideo(targetVideoUrl);

                // å‹•ç”»èª­ã¿è¾¼ã¿å¤±æ•— or abortæ¤œçŸ¥ â†’ é™ã‹ã«çµ‚äº†
                if (!STATE.frameExtractorVideo) {
                    console.log('[extractAllFrames] å‹•ç”»èª­ã¿è¾¼ã¿ä¸­æ­¢ï¼ˆæ¬¡ã®å‹•ç”»ã¸ï¼‰');
                    return;
                }

                // å†åº¦ç¢ºèª: èª­ã¿è¾¼ã¿ä¸­ã«å‹•ç”»ãŒåˆ‡ã‚Šæ›¿ã‚ã£ãŸå¯èƒ½æ€§
                if (STATE.currentVideoUrl !== targetVideoUrl) {
                    console.log('[extractAllFrames] å‹•ç”»èª­ã¿è¾¼ã¿å®Œäº†å¾Œã«åˆ‡ã‚Šæ›¿ã‚ã‚Šã‚’æ¤œçŸ¥');
                    return;
                }

                for (let i = 0; i < STATE.totalCells; i++) {
                    // ä¸­æ–­æ¡ä»¶1: abortedãƒ•ãƒ©ã‚°
                    if (STATE.aborted) {
                        console.log(`[extractAllFrames] ä¸­æ–­ (aborted): ${i}/${STATE.totalCells}ãƒ•ãƒ¬ãƒ¼ãƒ å®Œäº†`);
                        break;
                    }

                    // ä¸­æ–­æ¡ä»¶2: å‹•ç”»ãŒåˆ‡ã‚Šæ›¿ã‚ã£ãŸï¼ˆé‡è¦ï¼ï¼‰
                    if (STATE.currentVideoUrl !== targetVideoUrl) {
                        console.log(`[extractAllFrames] ä¸­æ–­ (å‹•ç”»åˆ‡ã‚Šæ›¿ãˆ): ${i}/${STATE.totalCells}ãƒ•ãƒ¬ãƒ¼ãƒ å®Œäº†`);
                        break;
                    }

                    // Extract thumbnail from center of cell (0.5 offset)
                    const timestamp = (i + 0.5) * CONFIG.secondsPerCell;
                    const cell = elements.thumbnailGrid.children[i];
                    if (!cell) continue;

                    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
                    const cached = frameCache.get(timestamp);
                    if (cached) {
                        displayFrame(cell, cached);
                        continue;
                    }

                    // ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡º
                    const frame = await extractFrame(STATE.frameExtractorVideo, timestamp);

                    // æŠ½å‡ºå®Œäº†å¾Œã€å†åº¦ä¸­æ–­ãƒã‚§ãƒƒã‚¯ï¼ˆå‹•ç”»åˆ‡ã‚Šæ›¿ã‚ã‚Šã‚„abortã‚’æ¤œå‡ºï¼‰
                    if (frame && !STATE.aborted && STATE.currentVideoUrl === targetVideoUrl) {
                        frameCache.put(timestamp, frame);
                        displayFrame(cell, frame);
                    }

                    // CPUè² è·è»½æ¸›ã®ãŸã‚çŸ­æ™‚é–“å¾…æ©Ÿ
                    await new Promise(r => setTimeout(r, 5));
                }

                // æ­£å¸¸å®Œäº†
                if (!STATE.aborted && STATE.currentVideoUrl === targetVideoUrl) {
                    console.log(`[extractAllFrames] å®Œäº†: ${STATE.totalCells}/${STATE.totalCells}ãƒ•ãƒ¬ãƒ¼ãƒ `);
                }
            } catch (e) {
                // [2025-01-13] ã‚¨ãƒ©ãƒ¼ã¯é™ã‹ã«å‡¦ç†ï¼ˆUXã‚’å£Šã•ãªã„ï¼‰
                // å‹•ç”»åˆ‡ã‚Šæ›¿ãˆã‚„abortã«ã‚ˆã‚‹ä¸­æ–­ã¯æ­£å¸¸ãªå‹•ä½œãªã®ã§ã‚¨ãƒ©ãƒ¼æ‰±ã„ã—ãªã„
                console.log('[extractAllFrames] å‡¦ç†ä¸­æ–­ã¾ãŸã¯ã‚¨ãƒ©ãƒ¼ï¼ˆæ¬¡ã®å‹•ç”»ã¸ï¼‰');
            } finally {
                STATE.isExtracting = false;

                // æŠ½å‡ºç”¨videoè¦ç´ ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                if (STATE.frameExtractorVideo) {
                    STATE.frameExtractorVideo.remove();
                    STATE.frameExtractorVideo = null;
                }
            }
        }

        // [2025-01-13] å‹•ç”»èª­ã¿è¾¼ã¿: 2ç§’ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ + 100msãƒãƒ¼ãƒªãƒ³ã‚°ã§abortæ¤œçŸ¥
        function createExtractorVideo(url) {
            return new Promise((resolve) => {
                const video = document.createElement('video');
                video.style.display = 'none';
                video.muted = true;
                video.playsInline = true;
                video.preload = 'auto';
                if (url.startsWith('http') && !url.startsWith(location.origin)) {
                    video.crossOrigin = 'anonymous';
                }
                video.src = url;

                let resolved = false;
                let pollInterval = null;

                const cleanup = () => {
                    video.removeEventListener('loadeddata', onReady);
                    video.removeEventListener('canplay', onReady);
                    video.removeEventListener('error', onError);
                };

                const onReady = () => {
                    if (resolved) return;
                    resolved = true;
                    clearInterval(pollInterval);
                    cleanup();
                    console.log('[createExtractorVideo] å‹•ç”»èª­ã¿è¾¼ã¿å®Œäº†');
                    resolve(video);
                };

                const onError = () => {
                    if (resolved) return;
                    resolved = true;
                    clearInterval(pollInterval);
                    cleanup();
                    video.remove();
                    console.log('[createExtractorVideo] å‹•ç”»èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ï¼ˆé™ã‹ã«ä¸­æ­¢ï¼‰');
                    resolve(null); // rejectã§ã¯ãªãnullã‚’è¿”ã™
                };

                video.addEventListener('loadeddata', onReady);
                video.addEventListener('canplay', onReady);
                video.addEventListener('error', onError);

                // 100msã”ã¨ã«ãƒãƒ¼ãƒªãƒ³ã‚°ï¼ˆæœ€å¤§2ç§’ = 20å›ãƒã‚§ãƒƒã‚¯ï¼‰
                let checkCount = 0;
                pollInterval = setInterval(() => {
                    checkCount++;

                    // å‹•ç”»ãŒåˆ‡ã‚Šæ›¿ã‚ã£ãŸã‚‰å³åº§ã«ä¸­æ­¢
                    if (STATE.currentVideoUrl !== url) {
                        if (!resolved) {
                            resolved = true;
                            clearInterval(pollInterval);
                            cleanup();
                            video.remove();
                            console.log('[createExtractorVideo] å‹•ç”»åˆ‡ã‚Šæ›¿ãˆæ¤œçŸ¥ï¼ˆé™ã‹ã«ä¸­æ­¢ï¼‰');
                            resolve(null);
                        }
                        return;
                    }

                    // abortãƒ•ãƒ©ã‚°ãŒç«‹ã£ãŸã‚‰ä¸­æ­¢
                    if (STATE.aborted) {
                        if (!resolved) {
                            resolved = true;
                            clearInterval(pollInterval);
                            cleanup();
                            video.remove();
                            console.log('[createExtractorVideo] abortæ¤œçŸ¥ï¼ˆé™ã‹ã«ä¸­æ­¢ï¼‰');
                            resolve(null);
                        }
                        return;
                    }

                    // 2ç§’ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
                    if (checkCount >= 20) {
                        clearInterval(pollInterval);
                        if (!resolved) {
                            resolved = true;
                            cleanup();
                            // readyState >= 2ãªã‚‰éƒ¨åˆ†çš„ã«ä½¿ãˆã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã®ã§è¿”ã™
                            if (video.readyState >= 2) {
                                console.log('[createExtractorVideo] ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã ãŒéƒ¨åˆ†çš„ã«ä½¿ç”¨å¯èƒ½');
                                resolve(video);
                            } else {
                                video.remove();
                                console.log('[createExtractorVideo] ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆé™ã‹ã«ä¸­æ­¢ï¼‰');
                                resolve(null);
                            }
                        }
                    }
                }, 100);

                document.body.appendChild(video);
                video.load();
            });
        }

        function extractFrame(video, timestamp) {
            return new Promise(resolve => {
                if (Math.abs(video.currentTime - timestamp) < 0.1 && video.readyState >= 2) {
                    resolve(captureFrame(video));
                    return;
                }

                let resolved = false;

                const onSeeked = () => {
                    if (resolved) return;
                    resolved = true;
                    video.removeEventListener('seeked', onSeeked);
                    setTimeout(() => resolve(captureFrame(video)), 50);
                };

                video.addEventListener('seeked', onSeeked);
                video.currentTime = Math.min(timestamp, video.duration - 0.1);

                setTimeout(() => {
                    if (resolved) return;
                    resolved = true;
                    video.removeEventListener('seeked', onSeeked);
                    resolve(captureFrame(video));
                }, 5000);
            });
        }

        function captureFrame(video) {
            if (video.readyState < 2) return null;
            try {
                const canvas = document.createElement('canvas');
                canvas.width = CONFIG.thumbWidth;
                canvas.height = CONFIG.thumbHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                return canvas.toDataURL('image/jpeg', 0.8);
            } catch (e) {
                return null;
            }
        }

        function displayFrame(cell, dataUrl) {
            const loader = cell.querySelector('.cell-loader');
            if (loader) loader.remove();

            const existing = cell.querySelector('img');
            if (existing) existing.remove();

            const img = new Image();
            img.onload = () => {
                cell.insertBefore(img, cell.firstChild);
                requestAnimationFrame(() => img.classList.add('loaded'));
                cell.classList.add('loaded');
            };
            img.src = dataUrl;
        }

        // ==================================================
        // Marker
        // ==================================================

        function updateGridDimensions() {
            const grid = elements.thumbnailGrid;
            const rect = grid.getBoundingClientRect();
            STATE.gridWidth = rect.width;
            STATE.gridHeight = rect.height;

            // Get actual cell size (accounting for gap)
            const firstCell = grid.querySelector('.grid-cell');
            if (firstCell) {
                const cellRect = firstCell.getBoundingClientRect();
                STATE.cellWidth = cellRect.width;
                STATE.cellHeight = cellRect.height;

                // Calculate gap
                const gridStyle = getComputedStyle(grid);
                STATE.gridGap = parseFloat(gridStyle.gap) || 2;
            } else {
                STATE.cellWidth = rect.width / CONFIG.columns;
                STATE.cellHeight = rect.height / STATE.totalRows;
                STATE.gridGap = 2;
            }
        }

        function initializeMarker() {
            STATE.markerSize = Math.max(24, Math.min(STATE.cellWidth, STATE.cellHeight) * 0.42);
            elements.svgMarker.style.display = 'block';
            elements.svgMarker.style.width = `${STATE.markerSize}px`;
            elements.svgMarker.style.height = `${STATE.markerSize}px`;

            STATE.markerX = 0;
            STATE.markerY = STATE.cellHeight / 2;
            STATE.targetX = STATE.markerX;
            STATE.targetY = STATE.markerY;
            updateMarkerPosition();
        }

        function updateMarkerPosition() {
            const offsetX = STATE.markerSize / 2;
            const offsetY = STATE.markerSize / 2;
            elements.svgMarker.style.transform = `translate(${STATE.markerX - offsetX}px, ${STATE.markerY - offsetY}px)`;
        }

        function moveMarkerTo(x, y, animate = true) {
            STATE.targetX = Math.max(0, Math.min(x, STATE.gridWidth));
            STATE.targetY = Math.max(0, Math.min(y, STATE.gridHeight));

            if (animate && !STATE.isAnimating) {
                STATE.isAnimating = true;
                animateMarker();
            } else if (!animate) {
                STATE.markerX = STATE.targetX;
                STATE.markerY = STATE.targetY;
                updateMarkerPosition();
            }
        }

        function animateMarker() {
            const dx = STATE.targetX - STATE.markerX;
            const dy = STATE.targetY - STATE.markerY;

            if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) {
                STATE.markerX = STATE.targetX;
                STATE.markerY = STATE.targetY;
                STATE.isAnimating = false;
                updateMarkerPosition();
                return;
            }

            STATE.markerX += dx * 0.15;
            STATE.markerY += dy * 0.15;
            updateMarkerPosition();

            STATE.animationId = requestAnimationFrame(animateMarker);
        }

        function calculateMarkerPositionFromTime(currentTime) {
            if (STATE.totalCells === 0 || CONFIG.secondsPerCell <= 0) {
                return { x: 0, y: STATE.cellHeight / 2 };
            }

            const gap = STATE.gridGap || 2;
            const continuousCellIndex = currentTime / CONFIG.secondsPerCell;
            let row = Math.floor(continuousCellIndex / CONFIG.columns);
            row = Math.max(0, Math.min(row, STATE.totalRows - 1));

            const positionInRow = continuousCellIndex - (row * CONFIG.columns);
            const col = Math.floor(positionInRow);
            const colFraction = positionInRow - col;

            // X position (account for gap)
            const cellPlusGapX = STATE.cellWidth + gap;
            const x = col * cellPlusGapX + colFraction * STATE.cellWidth;

            // Y position (account for gap, cell center)
            const cellPlusGapY = STATE.cellHeight + gap;
            const y = row * cellPlusGapY + STATE.cellHeight / 2;

            return {
                x: Math.max(0, Math.min(x, STATE.gridWidth)),
                y: Math.max(STATE.cellHeight / 2, Math.min(y, STATE.gridHeight - STATE.cellHeight / 2))
            };
        }

        function calculateTimeFromPosition(x, y) {
            // Account for gap
            const gap = STATE.gridGap || 2;
            const cellPlusGap = STATE.cellHeight + gap;

            // Calculate row from Y
            const rowContinuous = y / cellPlusGap;
            const row = Math.max(0, Math.min(Math.floor(rowContinuous), STATE.totalRows - 1));

            // Calculate column from X (account for gap)
            const cellPlusGapX = STATE.cellWidth + gap;
            const colContinuous = x / cellPlusGapX;
            const col = Math.max(0, Math.min(Math.floor(colContinuous), CONFIG.columns - 1));
            const xInCol = x - col * cellPlusGapX;
            const colFraction = Math.max(0, Math.min(xInCol / STATE.cellWidth, 1));

            // Calculate continuous cell index
            const continuousCellIndex = row * CONFIG.columns + col + colFraction;
            const timestamp = continuousCellIndex * CONFIG.secondsPerCell;

            return Math.max(0, Math.min(timestamp, CONFIG.videoDuration));
        }

        function moveToCell(col, row) {
            col = Math.max(0, col);
            row = Math.max(0, row);

            const cellIndex = row * CONFIG.columns + col;
            const lastIndex = STATE.totalCells - 1;

            if (cellIndex > lastIndex) {
                row = Math.floor(lastIndex / CONFIG.columns);
                col = lastIndex % CONFIG.columns;
            }

            STATE.currentCellX = col;
            STATE.currentCellY = row;

            const x = col * STATE.cellWidth;
            const y = (row + 0.5) * STATE.cellHeight;
            moveMarkerTo(x, y, true);

            const time = (row * CONFIG.columns + col) * CONFIG.secondsPerCell;
            elements.videoPlayer.currentTime = Math.min(time, CONFIG.videoDuration);
            updateDisplay();
            scrollToMarker();
        }

        function scrollToMarker() {
            const container = elements.gridContainer;
            const markerTop = STATE.markerY;
            const viewportHeight = container.clientHeight;
            const scrollTop = container.scrollTop;

            if (markerTop < scrollTop + 50) {
                container.scrollTo({ top: Math.max(0, markerTop - 100), behavior: 'smooth' });
            } else if (markerTop > scrollTop + viewportHeight - 50) {
                container.scrollTo({ top: markerTop - viewportHeight + 100, behavior: 'smooth' });
            }
        }

        // ==================================================
        // Display Update
        // ==================================================

        function updateDisplay() {
            const time = elements.videoPlayer.currentTime;
            elements.currentTime.textContent = formatTime(time);
            elements.overlayTime.textContent = formatTime(time);
            elements.overlayCell.textContent = `(${STATE.currentCellX}, ${STATE.currentCellY})`;
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }

        function formatTimeShort(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        function showLoading(text) {
            elements.loadingText.textContent = text;
            elements.loadingOverlay.classList.add('visible');
        }

        function hideLoading() {
            elements.loadingOverlay.classList.remove('visible');
        }

        // ==================================================
        // Events
        // ==================================================

        function setupEvents() {
            // Grid panel toggle
            elements.gridToggle.addEventListener('click', () => {
                const isCollapsed = elements.gridPanel.classList.toggle('collapsed');
                elements.gridToggle.textContent = isCollapsed ? 'â–²' : 'â–¼';
                // Recalculate grid dimensions
                if (!isCollapsed && STATE.currentVideoUrl) {
                    setTimeout(updateGridDimensions, 350);
                }
            });

            // Left panel toggle
            elements.leftPanelToggle.addEventListener('click', () => {
                const isCollapsed = elements.leftPanel.classList.toggle('collapsed');
                elements.leftPanelToggle.textContent = isCollapsed ? 'â–¶' : 'â—€';
            });

            // File selection
            elements.uploadDropzone.addEventListener('click', () => elements.fileInput.click());
            elements.fileInput.addEventListener('change', e => {
                if (e.target.files[0]) handleFileSelect(e.target.files[0]);
            });

            // Drag and drop
            elements.uploadDropzone.addEventListener('dragover', e => {
                e.preventDefault();
                elements.uploadDropzone.classList.add('dragover');
            });
            elements.uploadDropzone.addEventListener('dragleave', () => {
                elements.uploadDropzone.classList.remove('dragover');
            });
            elements.uploadDropzone.addEventListener('drop', e => {
                e.preventDefault();
                elements.uploadDropzone.classList.remove('dragover');
                if (e.dataTransfer.files[0]) handleFileSelect(e.dataTransfer.files[0]);
            });

            // Playback controls
            elements.playBtn.addEventListener('click', () => {
                if (elements.videoPlayer.paused) {
                    elements.videoPlayer.play();
                    elements.playBtn.textContent = 'â¸ åœæ­¢';
                } else {
                    elements.videoPlayer.pause();
                    elements.playBtn.textContent = 'â–¶ å†ç”Ÿ';
                }
            });

            // Video events
            let lastScrollTime = 0;
            elements.videoPlayer.addEventListener('timeupdate', () => {
                if (!STATE.isDragging) {
                    const pos = calculateMarkerPositionFromTime(elements.videoPlayer.currentTime);
                    moveMarkerTo(pos.x, pos.y, true);
                    updateDisplay();

                    // Auto-scroll to marker (throttled to 500ms)
                    const now = Date.now();
                    if (now - lastScrollTime > 500) {
                        scrollToMarker();
                        lastScrollTime = now;
                    }
                }
            });

            elements.videoPlayer.addEventListener('play', () => {
                elements.playBtn.textContent = 'â¸ åœæ­¢';
            });

            elements.videoPlayer.addEventListener('pause', () => {
                elements.playBtn.textContent = 'â–¶ å†ç”Ÿ';
            });

            // Grid settings
            elements.regenerateBtn.addEventListener('click', generateThumbnails);
            elements.columnsSelect.addEventListener('change', () => {
                if (STATE.currentVideoUrl) generateThumbnails();
            });
            elements.intervalSelect.addEventListener('change', () => {
                if (STATE.currentVideoUrl) generateThumbnails();
            });

            // Grid interaction (mouse)
            const grid = elements.thumbnailGrid;

            grid.addEventListener('mousedown', e => {
                e.preventDefault();
                STATE.isDragging = true;
                handleGridInteraction(e.clientX, e.clientY);
            });

            document.addEventListener('mousemove', e => {
                if (STATE.isDragging) handleGridInteraction(e.clientX, e.clientY);
            });

            document.addEventListener('mouseup', () => {
                if (STATE.isDragging) {
                    STATE.isDragging = false;
                    scrollToMarker();
                }
            });

            // Grid interaction (touch)
            grid.addEventListener('touchstart', e => {
                e.preventDefault();
                STATE.isDragging = true;
                const touch = e.touches[0];
                handleGridInteraction(touch.clientX, touch.clientY);
            }, { passive: false });

            grid.addEventListener('touchmove', e => {
                if (STATE.isDragging) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    handleGridInteraction(touch.clientX, touch.clientY);
                }
            }, { passive: false });

            grid.addEventListener('touchend', () => {
                if (STATE.isDragging) {
                    STATE.isDragging = false;
                    scrollToMarker();
                }
            });

            grid.addEventListener('click', handleGridClick);

            // Keyboard
            document.addEventListener('keydown', e => {
                if (!STATE.currentVideoUrl) return;

                switch (e.key) {
                    case ' ':
                        e.preventDefault();
                        elements.playBtn.click();
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        moveToCell(STATE.currentCellX - 1, STATE.currentCellY);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        moveToCell(STATE.currentCellX + 1, STATE.currentCellY);
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        moveToCell(STATE.currentCellX, STATE.currentCellY - 1);
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        moveToCell(STATE.currentCellX, STATE.currentCellY + 1);
                        break;
                    case 'Home':
                        e.preventDefault();
                        moveToCell(0, 0);
                        break;
                    case 'End':
                        e.preventDefault();
                        const lastIdx = STATE.totalCells - 1;
                        moveToCell(lastIdx % CONFIG.columns, Math.floor(lastIdx / CONFIG.columns));
                        break;
                }
            });
        }

        function handleGridClick(e) {
            handleGridInteraction(e.clientX, e.clientY);
        }

        function handleGridInteraction(clientX, clientY) {
            const grid = elements.thumbnailGrid;
            const rect = grid.getBoundingClientRect();

            const x = clientX - rect.left;
            const y = clientY - rect.top;

            const clampedX = Math.max(0, Math.min(x, STATE.gridWidth));
            const clampedY = Math.max(0, Math.min(y, STATE.gridHeight));

            moveMarkerTo(clampedX, clampedY, false);

            const time = calculateTimeFromPosition(clampedX, clampedY);

            // Force video frame update when paused
            const video = elements.videoPlayer;
            const wasPaused = video.paused;
            video.currentTime = time;

            // If video is paused, force frame render by briefly playing
            if (wasPaused && video.readyState >= 2) {
                video.play().then(() => {
                    video.pause();
                }).catch(() => {
                    // Ignore autoplay restrictions
                });
            }

            STATE.currentCellX = Math.floor(clampedX / STATE.cellWidth);
            STATE.currentCellY = Math.floor(clampedY / STATE.cellHeight);

            updateDisplay();
        }

        // ==================================================
        // Initialize
        // ==================================================

        setupEvents();
    </script>
</body>
</html>
