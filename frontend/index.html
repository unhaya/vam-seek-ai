<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VAM Web - 2Dã‚·ãƒ¼ã‚¯ãƒãƒ¼ã‚«ãƒ¼</title>
    <style>
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #252526;
            --bg-tertiary: #2d2d30;
            --border-color: #3c3c3c;
            --accent: #0e639c;
            --highlight: #e94560;
            --text: #cccccc;
            --text-dim: #808080;
            --marker-glow: rgba(233, 69, 96, 0.6);
            --success: #4caf50;
            --warning: #ffc107;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Segoe UI', 'Yu Gothic UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
        }

        /* ==================== ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ ==================== */
        .app-container {
            display: flex;
            height: calc(100vh - 24px);
            width: 100vw;
        }

        /* ãƒ„ãƒªãƒ¼ãƒ“ãƒ¥ãƒ¼ï¼ˆå·¦ãƒ‘ãƒãƒ«ï¼‰ */
        .tree-panel {
            width: 280px;
            min-width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: width 0.2s ease, min-width 0.2s ease, opacity 0.2s ease;
            overflow: hidden;
        }

        .tree-panel.collapsed {
            width: 0;
            min-width: 0;
            opacity: 0;
            border-right: none;
        }

        .tree-header {
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 12px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tree-content {
            flex: 1;
            overflow-y: auto;
            padding: 4px 0;
        }

        /* ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒªã‚¢ */
        .upload-area {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .upload-dropzone {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .upload-dropzone:hover,
        .upload-dropzone.dragover {
            border-color: var(--accent);
            background: rgba(14, 99, 156, 0.1);
        }

        .upload-dropzone.uploading {
            border-color: var(--warning);
            background: rgba(255, 193, 7, 0.1);
        }

        .upload-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .upload-text {
            font-size: 12px;
            color: var(--text-dim);
        }

        .upload-progress {
            margin-top: 8px;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            display: none;
        }

        .upload-progress.visible {
            display: block;
        }

        .upload-progress-bar {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s;
        }

        .video-list {
            padding: 8px 0;
        }

        .video-item {
            padding: 8px 12px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            border-left: 3px solid transparent;
        }

        .video-item:hover {
            background: var(--bg-tertiary);
        }

        .video-item.selected {
            background: var(--accent);
            border-left-color: var(--highlight);
        }

        .video-item-icon {
            font-size: 16px;
        }

        .video-item-info {
            flex: 1;
            overflow: hidden;
        }

        .video-item-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .video-item-duration {
            font-size: 10px;
            color: var(--text-dim);
        }

        /* ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ */
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¨ãƒªã‚¢ï¼ˆä¸­å¤®ï¼‰ */
        .player-area {
            flex: 1;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .player-placeholder {
            color: var(--text-dim);
            font-size: 14px;
            text-align: center;
        }

        #videoPlayer {
            max-width: 100%;
            max-height: 100%;
            display: none;
        }

        #videoPlayer.visible {
            display: block;
        }

        /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ */
        .control-bar {
            height: 40px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 12px;
            gap: 12px;
        }

        .control-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text);
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .control-btn:hover {
            background: var(--accent);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .time-display {
            font-family: 'Consolas', monospace;
            font-size: 13px;
            color: var(--text);
            min-width: 140px;
        }

        .time-highlight {
            color: var(--highlight);
            font-weight: bold;
        }

        /* ã‚°ãƒªãƒƒãƒ‰ãƒ‘ãƒãƒ«ï¼ˆå³å´ï¼‰ */
        .grid-panel {
            width: 400px;
            min-width: 300px;
            max-width: 600px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .grid-header {
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .grid-settings {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .grid-setting-label {
            font-size: 10px;
            color: var(--text-dim);
        }

        .grid-setting-input {
            width: 50px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text);
            padding: 2px 4px;
            font-size: 11px;
            border-radius: 2px;
        }

        .grid-setting-select {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text);
            padding: 2px 6px;
            font-size: 11px;
            border-radius: 2px;
            cursor: pointer;
        }

        .grid-setting-select:hover {
            border-color: var(--accent);
        }

        .grid-info {
            color: var(--text-dim);
        }

        /* ã‚°ãƒªãƒƒãƒ‰ã‚³ãƒ³ãƒ†ãƒŠ */
        .grid-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            background: var(--bg-primary);
        }

        .grid-scroll-wrapper {
            position: relative;
            width: 100%;
        }

        /* ã‚°ãƒªãƒƒãƒ‰æœ¬ä½“ */
        .thumbnail-grid {
            display: grid;
            gap: 1px;
            background: var(--border-color);
            width: 100%;
        }

        .grid-cell {
            aspect-ratio: 16/9;
            background: var(--bg-tertiary);
            position: relative;
            overflow: hidden;
        }

        .grid-cell img,
        .grid-cell canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            pointer-events: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-user-drag: none;
        }

        /* ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        .grid-cell canvas {
            opacity: 0;
            transition: opacity 0.4s ease-in-out;
        }

        .grid-cell canvas.loaded {
            opacity: 1;
        }

        .grid-cell.placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: var(--text-dim);
        }

        /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ãƒ”ãƒŠãƒ¼ï¼ˆã‚»ãƒ«ç”¨ï¼‰ */
        .grid-cell .cell-loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .grid-cell.frame-loaded .cell-loader {
            display: none;
        }

        .grid-cell .cell-time {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0,0,0,0.7);
            padding: 1px 4px;
            font-size: 9px;
            border-radius: 2px;
            pointer-events: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* ã‚°ãƒªãƒƒãƒ‰å…¨ä½“ã®é¸æŠé˜²æ­¢ */
        .thumbnail-grid {
            -webkit-user-select: none;
            user-select: none;
        }

        /* SVGãƒãƒ¼ã‚«ãƒ¼ï¼ˆVAMæº–æ‹ ï¼šæ»‘ã‚‰ã‹ã«é€£ç¶šç§»å‹•ï¼‰ */
        .svg-marker {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 50;
            display: none;  /* åˆæœŸéè¡¨ç¤ºã€JSã§blockåŒ– */
            /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¯JSã§åˆ¶å¾¡ï¼ˆtransformã§æ»‘ã‚‰ã‹ã«ç§»å‹•ï¼‰ */
            will-change: transform;
            filter: drop-shadow(0 0 6px rgba(183, 57, 43, 0.8)) drop-shadow(0 0 12px rgba(183, 57, 43, 0.5));
        }

        /* ãƒãƒ¼ã‚«ãƒ¼ã‚µã‚¤ã‚ºï¼ˆã‚»ãƒ«ã®32%ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰ */
        .svg-marker img {
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* ç¾åœ¨ã‚»ãƒ«ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼šéè¡¨ç¤ºã«ã‚‚å¯èƒ½ï¼‰ */
        .current-cell-highlight {
            position: absolute;
            border: 2px solid var(--highlight);
            box-shadow: inset 0 0 20px rgba(233, 69, 96, 0.3);
            pointer-events: none;
            z-index: 40;
            opacity: 0.5;
            display: none; /* ãƒãƒ¼ã‚«ãƒ¼ãŒã‚ã‚‹ã®ã§éè¡¨ç¤º */
        }

        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ */
        .status-bar {
            height: 24px;
            background: var(--accent);
            display: flex;
            align-items: center;
            padding: 0 12px;
            font-size: 11px;
            gap: 20px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .status-key {
            background: rgba(255,255,255,0.2);
            padding: 1px 6px;
            border-radius: 2px;
            font-family: monospace;
        }

        /* æƒ…å ±ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
        .info-overlay {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.85);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-family: 'Consolas', monospace;
            z-index: 60;
            pointer-events: none;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            gap: 16px;
            margin-bottom: 2px;
        }

        .info-label {
            color: var(--text-dim);
        }

        .info-value {
            color: var(--highlight);
            font-weight: bold;
        }

        /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            flex-direction: column;
            gap: 12px;
        }

        .loading-overlay.visible {
            display: flex;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-color);
            border-top-color: var(--highlight);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4a4a4a;
        }

        /* ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚’éš ã™ */
        #fileInput {
            display: none;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- å·¦: ãƒ„ãƒªãƒ¼ãƒ“ãƒ¥ãƒ¼ -->
        <div class="tree-panel" id="treePanel">
            <div class="tree-header">
                <span>å‹•ç”»ä¸€è¦§</span>
                <span style="color: var(--text-dim)">T ã§éè¡¨ç¤º</span>
            </div>
            <div class="upload-area">
                <div class="upload-dropzone" id="uploadDropzone">
                    <div class="upload-icon">ğŸ“</div>
                    <div class="upload-text">
                        å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—<br>
                        ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ
                    </div>
                    <div class="upload-progress" id="uploadProgress">
                        <div class="upload-progress-bar" id="uploadProgressBar"></div>
                    </div>
                </div>
                <input type="file" id="fileInput" accept="video/*">
            </div>
            <div class="tree-content">
                <div class="video-list" id="videoList">
                    <!-- å‹•ç”»ãƒªã‚¹ãƒˆ -->
                </div>
            </div>
        </div>

        <!-- ä¸­å¤®: ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ -->
        <div class="main-area">
            <div class="player-area" id="playerArea">
                <div class="player-placeholder" id="playerPlaceholder">
                    å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„<br>
                    <small>MP4, WebM, MKV, AVI, MOV å¯¾å¿œ</small>
                </div>
                <video id="videoPlayer" controls></video>
            </div>
            <div class="control-bar">
                <button type="button" class="control-btn" id="playBtn" disabled>â–¶ å†ç”Ÿ</button>
                <div class="time-display">
                    <span class="time-highlight" id="currentTime">00:00.00</span>
                    <span> / </span>
                    <span id="totalTime">00:00.00</span>
                </div>
                <div style="flex:1"></div>
                <div style="font-size: 12px; color: var(--text-dim)">
                    ã‚°ãƒªãƒƒãƒ‰: <span id="gridSizeDisplay">--</span>
                </div>
            </div>
        </div>

        <!-- å³: ã‚°ãƒªãƒƒãƒ‰ãƒ‘ãƒãƒ« -->
        <div class="grid-panel" id="gridPanel">
            <div class="grid-header">
                <span>ã‚µãƒ ãƒã‚¤ãƒ«ã‚°ãƒªãƒƒãƒ‰</span>
                <div class="grid-settings">
                    <span class="grid-setting-label">åˆ—:</span>
                    <select class="grid-setting-select" id="columnsSelect" title="åˆ—æ•°">
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5" selected>5</option>
                        <option value="6">6</option>
                        <option value="8">8</option>
                        <option value="10">10</option>
                    </select>
                    <span class="grid-setting-label">ç§’/ã‚»ãƒ«:</span>
                    <select class="grid-setting-select" id="intervalSelect" title="ç§’/ã‚»ãƒ«">
                        <option value="5">5s</option>
                        <option value="10">10s</option>
                        <option value="15" selected>15s</option>
                        <option value="30">30s</option>
                        <option value="60">1m</option>
                        <option value="120">2m</option>
                        <option value="300">5m</option>
                    </select>
                    <button type="button" class="control-btn" id="regenerateBtn" disabled>ç”Ÿæˆ</button>
                </div>
            </div>
            <div class="grid-container" id="gridContainer">
                <div class="grid-scroll-wrapper" id="gridScrollWrapper">
                    <div class="thumbnail-grid" id="thumbnailGrid"></div>
                    <!-- SVGãƒãƒ¼ã‚«ãƒ¼ï¼ˆVAMæº–æ‹ ï¼šæ»‘ã‚‰ã‹ã«é€£ç¶šç§»å‹•ï¼‰ -->
                    <div class="svg-marker" id="svgMarker">
                        <img src="assets/marker.svg" alt="marker" draggable="false">
                    </div>
                    <div class="current-cell-highlight" id="cellHighlight"></div>
                </div>
                <div class="info-overlay" id="infoOverlay">
                    <div class="info-row">
                        <span class="info-label">æ™‚é–“:</span>
                        <span class="info-value" id="overlayTime">00:00.00</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">ã‚»ãƒ«:</span>
                        <span class="info-value" id="overlayCell">(0, 0)</span>
                    </div>
                </div>
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <div id="loadingText">ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆä¸­...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ -->
    <div class="status-bar">
        <div class="status-item">
            <span class="status-key">T</span> ãƒ„ãƒªãƒ¼è¡¨ç¤ºåˆ‡æ›¿
        </div>
        <div class="status-item">
            <span class="status-key">â†‘â†“â†â†’</span> ãƒãƒ¼ã‚«ãƒ¼ç§»å‹•
        </div>
        <div class="status-item">
            <span class="status-key">Space</span> å†ç”Ÿ/åœæ­¢
        </div>
        <div class="status-item">
            <span class="status-key">ã‚¯ãƒªãƒƒã‚¯</span> ã‚·ãƒ¼ã‚¯
        </div>
        <div style="flex:1"></div>
        <div class="status-item" id="apiStatus">API: æ¥ç¶šä¸­...</div>
    </div>

    <script>
        // ==================================================
        // VAM Web - 2Dã‚·ãƒ¼ã‚¯ãƒãƒ¼ã‚«ãƒ¼ (å‹•ç”»å¯¾å¿œç‰ˆ)
        // ==================================================

        // åŒä¸€ã‚ªãƒªã‚¸ãƒ³ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆCORSå•é¡Œã‚’å›é¿ï¼‰
        // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰ç›´æ¥index.htmlã‚’é…ä¿¡ã™ã‚‹å ´åˆã¯ç©ºæ–‡å­—åˆ—
        const API_BASE = '';

        // VAMæº–æ‹ ã®ãƒ—ãƒªã‚»ãƒƒãƒˆå€¤
        const INTERVAL_PRESETS = [
            { value: 5, label: "5s" },
            { value: 10, label: "10s" },
            { value: 15, label: "15s" },   // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
            { value: 30, label: "30s" },
            { value: 60, label: "1m" },
            { value: 120, label: "2m" },
            { value: 300, label: "5m" }
        ];

        const COLUMN_PRESETS = [3, 4, 5, 6, 8, 10];  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 5

        // è¨­å®š
        const CONFIG = {
            columns: 5,
            secondsPerCell: 15,
            videoDuration: 0,
            thumbWidth: 160,
            thumbHeight: 90
        };

        // çŠ¶æ…‹
        const STATE = {
            // ãƒãƒ¼ã‚«ãƒ¼ä½ç½®ï¼ˆãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ï¼‰- VAMæº–æ‹ ã®æ»‘ã‚‰ã‹ãªç§»å‹•ç”¨
            markerX: 0,           // ç¾åœ¨ã®Xåº§æ¨™ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
            markerY: 0,           // ç¾åœ¨ã®Yåº§æ¨™ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
            targetX: 0,           // ç›®æ¨™Xåº§æ¨™ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ï¼‰
            targetY: 0,           // ç›®æ¨™Yåº§æ¨™ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ï¼‰
            // ç›¸å¯¾åº§æ¨™ï¼ˆ0.0-1.0ï¼‰- æ™‚åˆ»è¨ˆç®—ç”¨
            currentRelX: 0,
            currentRelY: 0,
            // ã‚»ãƒ«åº§æ¨™ï¼ˆæ•´æ•°ï¼‰- è¡¨ç¤ºç”¨
            currentCellX: 0,
            currentCellY: 0,
            totalRows: 0,
            totalCells: 0,
            // ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
            gridWidth: 0,
            gridHeight: 0,
            cellWidth: 0,
            cellHeight: 0,
            // ãƒãƒ¼ã‚«ãƒ¼ã‚µã‚¤ã‚º
            markerSize: 40,
            // ãƒ‰ãƒ©ãƒƒã‚°çŠ¶æ…‹
            isDragging: false,
            // ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ç§»å‹•ãƒ•ãƒ©ã‚°ï¼ˆã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œæ™‚ã®è¿½å¾“åœæ­¢ç”¨ï¼‰
            isManuallyMoved: false,
            manualMoveTimeout: null,
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            animationId: null,
            isAnimating: false,
            // æ¥ç¶šçŠ¶æ…‹
            isApiConnected: false,
            currentVideoId: null,
            videos: [],
            // ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡ºç”¨
            frameExtractorVideo: null,
            isExtractingFrames: false,
            extractionAborted: false
        };

        // ==================================================
        // LRUãƒ•ãƒ¬ãƒ¼ãƒ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆVAMæº–æ‹ ï¼šãƒ¡ãƒ¢ãƒªä¸Šã«ä¿æŒï¼‰
        // ==================================================

        class FrameCache {
            constructor(maxSize = 200) {
                this.cache = new Map();
                this.maxSize = maxSize;
            }

            // ã‚­ãƒ¼ã‚’ç”Ÿæˆï¼ˆå‹•ç”»URL + ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼‰
            makeKey(videoSrc, timestamp) {
                return `${videoSrc}:${timestamp.toFixed(2)}`;
            }

            get(videoSrc, timestamp) {
                const key = this.makeKey(videoSrc, timestamp);
                if (this.cache.has(key)) {
                    // LRU: æœ€è¿‘ä½¿ç”¨ã—ãŸã‚‚ã®ã‚’æœ€å¾Œã«ç§»å‹•
                    const value = this.cache.get(key);
                    this.cache.delete(key);
                    this.cache.set(key, value);
                    return value;
                }
                return null;
            }

            put(videoSrc, timestamp, imageData) {
                const key = this.makeKey(videoSrc, timestamp);

                // æ—¢å­˜ãªã‚‰å‰Šé™¤ã—ã¦å†è¿½åŠ ï¼ˆLRUæ›´æ–°ï¼‰
                if (this.cache.has(key)) {
                    this.cache.delete(key);
                }

                // ã‚µã‚¤ã‚ºåˆ¶é™ãƒã‚§ãƒƒã‚¯
                while (this.cache.size >= this.maxSize) {
                    // æœ€å¤ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤
                    const oldestKey = this.cache.keys().next().value;
                    this.cache.delete(oldestKey);
                }

                this.cache.set(key, imageData);
            }

            clear() {
                this.cache.clear();
            }

            get size() {
                return this.cache.size;
            }
        }

        const frameCache = new FrameCache(200);

        // ==================================================
        // ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡ºï¼ˆvideo + canvas ã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚­ãƒ£ãƒ—ãƒãƒ£ï¼‰
        // ==================================================

        /**
         * éè¡¨ç¤ºã®videoè¦ç´ ã‹ã‚‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£
         * @param {HTMLVideoElement} video - ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡ºç”¨ã®videoè¦ç´ 
         * @param {number} timestamp - ã‚­ãƒ£ãƒ—ãƒãƒ£ã™ã‚‹æ™‚åˆ»ï¼ˆç§’ï¼‰
         * @returns {Promise<ImageData|null>} - ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ãŸç”»åƒãƒ‡ãƒ¼ã‚¿
         */
        async function extractFrame(video, timestamp) {
            return new Promise((resolve) => {
                // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
                const cached = frameCache.get(video.src, timestamp);
                if (cached) {
                    resolve(cached);
                    return;
                }

                // æ—¢ã«ãã®æ™‚åˆ»ã«ã„ã‚‹å ´åˆã¯å³åº§ã«ã‚­ãƒ£ãƒ—ãƒãƒ£
                if (Math.abs(video.currentTime - timestamp) < 0.1) {
                    const imageData = captureVideoFrame(video);
                    if (imageData) {
                        frameCache.put(video.src, timestamp, imageData);
                    }
                    resolve(imageData);
                    return;
                }

                // ã‚·ãƒ¼ã‚¯å®Œäº†ã‚’å¾…ã£ã¦ã‚­ãƒ£ãƒ—ãƒãƒ£
                const onSeeked = () => {
                    video.removeEventListener('seeked', onSeeked);
                    const imageData = captureVideoFrame(video);
                    if (imageData) {
                        frameCache.put(video.src, timestamp, imageData);
                    }
                    resolve(imageData);
                };

                video.addEventListener('seeked', onSeeked);
                video.currentTime = timestamp;

                // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ3ç§’ï¼‰
                setTimeout(() => {
                    video.removeEventListener('seeked', onSeeked);
                    resolve(null);
                }, 3000);
            });
        }

        /**
         * videoã‹ã‚‰canvasã«ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£
         * @param {HTMLVideoElement} video
         * @returns {ImageData|null}
         */
        function captureVideoFrame(video) {
            console.log('captureVideoFrame - readyState:', video.readyState, 'currentTime:', video.currentTime);
            if (video.readyState < 2) {
                console.warn('Video not ready, readyState:', video.readyState);
                return null;
            }

            try {
                const canvas = document.createElement('canvas');
                canvas.width = CONFIG.thumbWidth;
                canvas.height = CONFIG.thumbHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                console.log('Frame captured, dataUrl length:', dataUrl.length);

                return {
                    dataUrl: dataUrl,
                    width: canvas.width,
                    height: canvas.height
                };
            } catch (e) {
                console.error('captureVideoFrame error:', e);
                return null;
            }
        }

        /**
         * ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡ºç”¨ã®videoè¦ç´ ã‚’ä½œæˆ
         * @param {string} videoUrl
         * @returns {Promise<HTMLVideoElement>}
         */
        function createExtractorVideo(videoUrl) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.style.display = 'none';
                video.muted = true;
                video.preload = 'auto';
                // crossOriginã¯ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§ã¯ä¸è¦ï¼ˆCORSã‚¨ãƒ©ãƒ¼ã®åŸå› ã«ãªã‚‹ï¼‰
                // video.crossOrigin = 'anonymous';

                video.addEventListener('loadeddata', () => {
                    console.log('Extractor video loaded:', videoUrl);
                    resolve(video);
                });

                video.addEventListener('error', (e) => {
                    console.error('Video load error:', e);
                    reject(new Error('Video load failed'));
                });

                video.src = videoUrl;
                document.body.appendChild(video);
            });
        }

        /**
         * ã‚°ãƒªãƒƒãƒ‰å…¨ä½“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é †æ¬¡æŠ½å‡ºï¼ˆãƒ—ãƒ­ã‚°ãƒ¬ãƒƒã‚·ãƒ–è¡¨ç¤ºï¼‰
         */
        async function extractAllFrames() {
            if (!STATE.currentVideoId || STATE.isExtractingFrames) return;

            console.log('extractAllFrames started');
            STATE.isExtractingFrames = true;
            STATE.extractionAborted = false;

            const video = STATE.videos.find(v => v.video_id === STATE.currentVideoId);
            if (!video) {
                console.error('Video not found:', STATE.currentVideoId);
                STATE.isExtractingFrames = false;
                return;
            }

            try {
                // ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡ºç”¨videoè¦ç´ ã‚’ä½œæˆ
                if (STATE.frameExtractorVideo) {
                    STATE.frameExtractorVideo.remove();
                }
                const videoUrl = `${API_BASE}${video.video_url}`;
                console.log('Creating extractor video:', videoUrl);
                STATE.frameExtractorVideo = await createExtractorVideo(videoUrl);

                console.log('Extracting frames, total cells:', STATE.totalCells);

                // ã‚»ãƒ«ã‚’é †ç•ªã«å‡¦ç†
                for (let i = 0; i < STATE.totalCells; i++) {
                    if (STATE.extractionAborted) break;

                    const timestamp = i * CONFIG.secondsPerCell;
                    const cell = elements.thumbnailGrid.children[i];
                    if (!cell) continue;

                    // æ—¢ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ã‚ã‚Œã°ã‚¹ã‚­ãƒƒãƒ—
                    const cached = frameCache.get(videoUrl, timestamp);
                    if (cached) {
                        displayFrameInCell(cell, cached, i);
                        continue;
                    }

                    // ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡º
                    const imageData = await extractFrame(STATE.frameExtractorVideo, timestamp);
                    if (imageData && !STATE.extractionAborted) {
                        displayFrameInCell(cell, imageData, i);
                    } else {
                        console.warn('Frame extraction failed for cell:', i, 'timestamp:', timestamp);
                    }

                    // UIæ›´æ–°ã®ãŸã‚å°‘ã—å¾…ã¤ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«5msï¼‰
                    await new Promise(r => setTimeout(r, 5));
                }

                console.log('Frame extraction completed');

            } catch (error) {
                console.error('Frame extraction error:', error);
            } finally {
                STATE.isExtractingFrames = false;
            }
        }

        /**
         * ã‚»ãƒ«ã«ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¡¨ç¤ºï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
         */
        function displayFrameInCell(cell, imageData, index) {
            console.log('displayFrameInCell:', index);

            // ãƒ­ãƒ¼ãƒ€ãƒ¼ã‚’å‰Šé™¤
            const loader = cell.querySelector('.cell-loader');
            if (loader) loader.remove();

            // æ—¢å­˜ã®canvas/imgã‚’å‰Šé™¤
            const existingMedia = cell.querySelector('canvas, img');
            if (existingMedia) existingMedia.remove();

            // imgè¦ç´ ã§ç›´æ¥è¡¨ç¤ºï¼ˆcanvasã‚ˆã‚Šã‚·ãƒ³ãƒ—ãƒ«ï¼‰
            const img = new Image();
            img.onload = () => {
                console.log('Image loaded for cell:', index);
                img.style.opacity = '0';
                img.style.transition = 'opacity 0.4s ease-in-out';
                cell.insertBefore(img, cell.firstChild);

                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                requestAnimationFrame(() => {
                    img.style.opacity = '1';
                });

                cell.classList.add('frame-loaded');
            };
            img.onerror = (e) => {
                console.error('Image load error for cell:', index, e);
            };
            img.src = imageData.dataUrl;
        }

        /**
         * ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡ºã‚’ä¸­æ­¢
         */
        function abortFrameExtraction() {
            STATE.extractionAborted = true;
            if (STATE.frameExtractorVideo) {
                STATE.frameExtractorVideo.remove();
                STATE.frameExtractorVideo = null;
            }
        }

        // DOMè¦ç´ 
        const elements = {
            treePanel: document.getElementById('treePanel'),
            gridPanel: document.getElementById('gridPanel'),
            gridContainer: document.getElementById('gridContainer'),
            gridScrollWrapper: document.getElementById('gridScrollWrapper'),
            thumbnailGrid: document.getElementById('thumbnailGrid'),
            svgMarker: document.getElementById('svgMarker'),
            cellHighlight: document.getElementById('cellHighlight'),
            currentTime: document.getElementById('currentTime'),
            totalTime: document.getElementById('totalTime'),
            gridSizeDisplay: document.getElementById('gridSizeDisplay'),
            overlayTime: document.getElementById('overlayTime'),
            overlayCell: document.getElementById('overlayCell'),
            apiStatus: document.getElementById('apiStatus'),
            videoPlayer: document.getElementById('videoPlayer'),
            playerPlaceholder: document.getElementById('playerPlaceholder'),
            uploadDropzone: document.getElementById('uploadDropzone'),
            fileInput: document.getElementById('fileInput'),
            uploadProgress: document.getElementById('uploadProgress'),
            uploadProgressBar: document.getElementById('uploadProgressBar'),
            videoList: document.getElementById('videoList'),
            playBtn: document.getElementById('playBtn'),
            columnsSelect: document.getElementById('columnsSelect'),
            intervalSelect: document.getElementById('intervalSelect'),
            regenerateBtn: document.getElementById('regenerateBtn'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            loadingText: document.getElementById('loadingText'),
            infoOverlay: document.getElementById('infoOverlay')
        };

        // ==================================================
        // åˆæœŸåŒ–
        // ==================================================

        function init() {
            setupEventListeners();
            checkApiConnection();
            renderEmptyGrid();
        }

        function renderEmptyGrid() {
            elements.thumbnailGrid.innerHTML = '';
            elements.gridSizeDisplay.textContent = '--';
            elements.svgMarker.style.display = 'none';
            elements.cellHighlight.style.display = 'none';
            elements.infoOverlay.style.display = 'none';
        }

        // ==================================================
        // VAMæº–æ‹ ï¼šé«˜ç²¾åº¦ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¨ˆç®—
        // å…ƒã‚³ãƒ¼ãƒ‰: vam5.70/utils/video_utils.py calculate_x_continuous_timestamp
        // ==================================================

        /**
         * Xè»¸é€£ç¶šãƒ¢ãƒ¼ãƒ‰å¯¾å¿œã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¨ˆç®—
         * â˜… VAMã‚ªãƒªã‚¸ãƒŠãƒ«ã‚³ãƒ¼ãƒ‰ã‚’1ãƒŸãƒªã‚‚ç‹‚ã‚ãšç§»æ¤ â˜…
         *
         * @param {number} relX - Xåº§æ¨™ã®ç›¸å¯¾ä½ç½®ï¼ˆ0.0-1.0ï¼‰
         * @param {number} relY - Yåº§æ¨™ã®ç›¸å¯¾ä½ç½®ï¼ˆ0.0-1.0ï¼‰
         * @param {number} gridWidth - ã‚°ãƒªãƒƒãƒ‰ã®åˆ—æ•°
         * @param {number} gridHeight - ã‚°ãƒªãƒƒãƒ‰ã®è¡Œæ•°
         * @param {number} videoDuration - å‹•ç”»ã®ç·æ™‚é–“ï¼ˆç§’ï¼‰
         * @param {number} secondsPerCell - 1ã‚»ãƒ«ã‚ãŸã‚Šã®ç§’æ•°
         * @returns {number} å†ç”Ÿé–‹å§‹æ™‚åˆ»ï¼ˆç§’ï¼‰
         */
        function calculateXContinuousTimestamp(relX, relY, gridWidth, gridHeight, videoDuration, secondsPerCell) {
            if (videoDuration <= 0) {
                return 0.0;
            }

            if (secondsPerCell && secondsPerCell > 0) {
                // Yè»¸: è¡Œå˜ä½ã§ä¸¸ã‚ã‚‹ï¼ˆVAMæº–æ‹ ï¼‰
                const rowIndex = Math.floor(relY * gridHeight);

                // Xè»¸: é€£ç¶šçš„ãªå€¤ã®ã¾ã¾è¨ˆç®—ï¼ˆé«˜ç²¾åº¦ï¼‰â˜…é‡è¦â˜…
                const colContinuous = relX * gridWidth;

                // é€£ç¶šçš„ãªã‚»ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
                const continuousCellIndex = rowIndex * gridWidth + colContinuous;

                // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’è¨ˆç®—
                const timestamp = continuousCellIndex * secondsPerCell;

                return Math.max(0.0, Math.min(timestamp, videoDuration));
            }

            // secondsPerCellãŒãªã„å ´åˆã¯å¾“æ¥ã®æ¯”ä¾‹è¨ˆç®—
            const RESET_INTERVAL = 20;
            const currentRow = relY * gridHeight;
            const actualRow = Math.floor(currentRow);

            const resetBlock = Math.floor(actualRow / RESET_INTERVAL);
            const rowInBlock = actualRow % RESET_INTERVAL;

            const blockStartRatio = (resetBlock * RESET_INTERVAL) / gridHeight;
            const blockStartTime = blockStartRatio * videoDuration;

            const cellsInBlock = rowInBlock * gridWidth + (relX * gridWidth);
            const maxCellsInBlock = RESET_INTERVAL * gridWidth;
            const blockProgressRatio = cellsInBlock / maxCellsInBlock;
            const blockDuration = (RESET_INTERVAL / gridHeight) * videoDuration;

            const timestamp = blockStartTime + (blockProgressRatio * blockDuration);

            return Math.max(0.0, Math.min(timestamp, videoDuration));
        }

        /**
         * çµ±ä¸€åº§æ¨™è¨ˆç®—ï¼ˆãƒã‚¦ã‚¹ä½ç½®ã‹ã‚‰ç›¸å¯¾åº§æ¨™ã‚’ç®—å‡ºï¼‰
         * â˜… VAMæº–æ‹ : _calculate_unified_coordinates â˜…
         *
         * @param {MouseEvent} e - ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
         * @returns {{relX: number, relY: number}} ç›¸å¯¾åº§æ¨™ï¼ˆ0.0-0.999999ï¼‰
         */
        function calculateUnifiedCoordinates(e) {
            const grid = elements.thumbnailGrid;
            const rect = grid.getBoundingClientRect();
            const container = elements.gridContainer;
            const cellEl = grid.children[0];
            if (!cellEl) return { relX: 0, relY: 0 };

            const cellHeight = cellEl.offsetHeight + 1;
            const totalGridHeight = STATE.totalRows * cellHeight;

            // ãƒ”ã‚¯ã‚»ãƒ«ä½ç½®ã‚’è¨ˆç®—
            const pixelX = e.clientX - rect.left;
            const pixelY = e.clientY - rect.top + container.scrollTop;

            // ç›¸å¯¾åº§æ¨™ã«å¤‰æ›ï¼ˆ0.0-1.0ï¼‰
            let relX = pixelX / rect.width;
            let relY = pixelY / totalGridHeight;

            // ç¯„å›²åˆ¶é™ï¼š0.0-0.999999ï¼ˆ1.0ã‚’é¿ã‘ã¦å¢ƒç•Œã‚¨ãƒ©ãƒ¼ã‚’é˜²æ­¢ï¼‰â˜…VAMæº–æ‹ â˜…
            relX = Math.max(0.0, Math.min(0.999999, relX));
            relY = Math.max(0.0, Math.min(0.999999, relY));

            return { relX, relY };
        }

        /**
         * å†ç”Ÿä½ç½®ã‹ã‚‰ã‚°ãƒªãƒƒãƒ‰åº§æ¨™ã‚’é€†ç®—
         * â˜… VAMæº–æ‹ : update_marker_position_for_playback â˜…
         *
         * @param {number} currentTime - ç¾åœ¨ã®å†ç”Ÿä½ç½®ï¼ˆç§’ï¼‰
         * @returns {{relX: number, relY: number, cellX: number, cellY: number}}
         */
        function calculateGridPositionFromTime(currentTime) {
            if (STATE.totalCells === 0 || CONFIG.secondsPerCell <= 0) {
                return { relX: 0, relY: 0, cellX: 0, cellY: 0 };
            }

            // é€£ç¶šçš„ãªã‚»ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
            const continuousCellIndex = currentTime / CONFIG.secondsPerCell;

            // è¡Œã‚’è¨ˆç®—
            const currentRow = Math.floor(continuousCellIndex / CONFIG.columns);

            // è¡Œå†…ã®ä½ç½®ï¼ˆå°æ•°å€¤ã‚’ä¿æŒï¼‰
            const positionInRow = continuousCellIndex - (currentRow * CONFIG.columns);

            // ã‚»ãƒ«åº§æ¨™ï¼ˆæ•´æ•°ï¼‰
            const cellX = Math.floor(positionInRow);
            const cellY = Math.min(currentRow, STATE.totalRows - 1);

            // ç›¸å¯¾åº§æ¨™ï¼ˆ0.0-1.0ï¼‰
            const relX = positionInRow / CONFIG.columns;
            const relY = (currentRow + 0.5) / STATE.totalRows;

            return {
                relX: Math.max(0, Math.min(relX, 0.999999)),
                relY: Math.max(0, Math.min(relY, 0.999999)),
                cellX: Math.max(0, Math.min(cellX, CONFIG.columns - 1)),
                cellY: Math.max(0, Math.min(cellY, STATE.totalRows - 1))
            };
        }

        // ==================================================
        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
        // ==================================================

        async function uploadVideo(file) {
            if (!file || !file.type.startsWith('video/')) {
                alert('å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            elements.uploadDropzone.classList.add('uploading');
            elements.uploadProgress.classList.add('visible');
            elements.uploadProgressBar.style.width = '0%';

            try {
                // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼ˆé€²æ—ã¯æ“¬ä¼¼çš„ã«è¡¨ç¤ºï¼‰
                let progress = 0;
                const progressInterval = setInterval(() => {
                    progress = Math.min(progress + 10, 90);
                    elements.uploadProgressBar.style.width = `${progress}%`;
                }, 200);

                const response = await fetch(`${API_BASE}/api/video/upload`, {
                    method: 'POST',
                    body: formData
                });

                clearInterval(progressInterval);
                elements.uploadProgressBar.style.width = '100%';

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¤±æ•—');
                }

                const data = await response.json();

                // å‹•ç”»ãƒªã‚¹ãƒˆã«è¿½åŠ 
                STATE.videos.push(data);
                renderVideoList();

                // å‹•ç”»ã‚’é¸æŠ
                selectVideo(data.video_id);

            } catch (error) {
                alert(`ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            } finally {
                elements.uploadDropzone.classList.remove('uploading');
                setTimeout(() => {
                    elements.uploadProgress.classList.remove('visible');
                }, 500);
            }
        }

        function renderVideoList() {
            elements.videoList.innerHTML = '';
            STATE.videos.forEach(video => {
                const item = document.createElement('div');
                item.className = 'video-item' + (video.video_id === STATE.currentVideoId ? ' selected' : '');
                item.innerHTML = `
                    <span class="video-item-icon">ğŸ¬</span>
                    <div class="video-item-info">
                        <div class="video-item-name">${video.filename}</div>
                        <div class="video-item-duration">${formatTime(video.duration)}</div>
                    </div>
                `;
                item.addEventListener('click', () => selectVideo(video.video_id));
                elements.videoList.appendChild(item);
            });
        }

        async function selectVideo(videoId) {
            STATE.currentVideoId = videoId;
            const video = STATE.videos.find(v => v.video_id === videoId);
            if (!video) return;

            // UIã‚’æ›´æ–°
            renderVideoList();

            // å‹•ç”»ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ã‚’è¨­å®š
            elements.videoPlayer.src = `${API_BASE}${video.video_url}`;
            elements.videoPlayer.classList.add('visible');
            elements.playerPlaceholder.style.display = 'none';
            elements.playBtn.disabled = false;
            elements.regenerateBtn.disabled = false;

            // è¨­å®šã‚’æ›´æ–°
            CONFIG.videoDuration = video.duration;
            elements.totalTime.textContent = formatTime(video.duration);

            // ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆ
            await generateThumbnails();
        }

        // ==================================================
        // ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡ºï¼‰
        // ==================================================

        async function generateThumbnails() {
            if (!STATE.currentVideoId) return;

            // æ—¢å­˜ã®ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡ºã‚’ä¸­æ­¢
            abortFrameExtraction();

            CONFIG.columns = parseInt(elements.columnsSelect.value) || 5;
            CONFIG.secondsPerCell = parseInt(elements.intervalSelect.value) || 15;

            showLoading('ã‚°ãƒªãƒƒãƒ‰è¨ˆç®—ä¸­...');

            try {
                // ã‚µãƒ¼ãƒãƒ¼å´ã§ã‚°ãƒªãƒƒãƒ‰è¨­å®šã®ã¿è¨ˆç®—ï¼ˆã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆã¯ã—ãªã„ï¼‰
                const response = await fetch(`${API_BASE}/api/grid/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        video_duration: CONFIG.videoDuration,
                        columns: CONFIG.columns,
                        seconds_per_cell: CONFIG.secondsPerCell
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'ã‚°ãƒªãƒƒãƒ‰è¨ˆç®—å¤±æ•—');
                }

                const data = await response.json();
                STATE.totalRows = data.rows;
                STATE.totalCells = data.total_cells;

                // ã‚°ãƒªãƒƒãƒ‰ã‚’æç”»ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§æŠ½å‡ºï¼‰
                renderThumbnailGrid();
                moveToCell(0, 0);

            } catch (error) {
                alert(`ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                renderEmptyGrid();
            } finally {
                hideLoading();
            }
        }

        function renderThumbnailGrid() {
            const grid = elements.thumbnailGrid;
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${CONFIG.columns}, 1fr)`;

            // ã‚°ãƒªãƒƒãƒ‰ã‚»ãƒ«ã‚’é…ç½®ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ ã¯å¾Œã‹ã‚‰æŠ½å‡ºï¼‰
            for (let i = 0; i < STATE.totalCells; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.index = i;

                const time = i * CONFIG.secondsPerCell;

                // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ãƒ”ãƒŠãƒ¼ã‚’è¿½åŠ 
                const loader = document.createElement('div');
                loader.className = 'cell-loader';
                cell.appendChild(loader);

                // æ™‚é–“ãƒ©ãƒ™ãƒ«
                const timeLabel = document.createElement('span');
                timeLabel.className = 'cell-time';
                timeLabel.textContent = formatTimeShort(time);
                cell.appendChild(timeLabel);

                grid.appendChild(cell);
            }

            // ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºè¡¨ç¤º
            elements.gridSizeDisplay.textContent = `${CONFIG.columns}åˆ— Ã— ${STATE.totalRows}è¡Œ`;

            // DOMãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å®Œäº†ã‚’å¾…ã£ã¦ã‹ã‚‰ãƒãƒ¼ã‚«ãƒ¼åˆæœŸåŒ–
            requestAnimationFrame(() => {
                // ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºã‚’è¨˜éŒ²
                updateGridDimensions();

                // ãƒãƒ¼ã‚«ãƒ¼è¡¨ç¤ºãƒ»åˆæœŸåŒ–
                initializeMarker();
                elements.infoOverlay.style.display = 'block';

                // ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡ºé–‹å§‹ï¼ˆãƒ—ãƒ­ã‚°ãƒ¬ãƒƒã‚·ãƒ–è¡¨ç¤ºï¼‰
                extractAllFrames();
            });
        }

        /**
         * ã‚°ãƒªãƒƒãƒ‰ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚µã‚¤ã‚ºã‚’æ›´æ–°
         */
        function updateGridDimensions() {
            const grid = elements.thumbnailGrid;
            const cellEl = grid.children[0];
            if (!cellEl) return;

            STATE.cellWidth = cellEl.offsetWidth + 1;  // +1 for gap
            STATE.cellHeight = cellEl.offsetHeight + 1;
            STATE.gridWidth = STATE.cellWidth * CONFIG.columns;
            STATE.gridHeight = STATE.cellHeight * STATE.totalRows;

            // ãƒãƒ¼ã‚«ãƒ¼ã‚µã‚¤ã‚ºï¼ˆã‚»ãƒ«ã®çŸ­è¾ºã®50%ã€æœ€å°24pxã€æœ€å¤§60pxï¼‰
            const minCellDimension = Math.min(STATE.cellWidth, STATE.cellHeight);
            STATE.markerSize = Math.max(24, Math.min(minCellDimension * 0.5, 60));
        }

        /**
         * SVGãƒãƒ¼ã‚«ãƒ¼ã‚’åˆæœŸåŒ–
         */
        function initializeMarker() {
            // ã‚»ãƒ«ã‚µã‚¤ã‚ºãŒå–å¾—ã§ãã¦ã„ãªã„å ´åˆã¯å†è©¦è¡Œ
            if (STATE.cellWidth === 0 || STATE.cellHeight === 0) {
                console.warn('Cell dimensions not ready, retrying...');
                requestAnimationFrame(() => {
                    updateGridDimensions();
                    initializeMarker();
                });
                return;
            }

            // ãƒãƒ¼ã‚«ãƒ¼ã‚µã‚¤ã‚ºãŒå°ã•ã™ãã‚‹å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
            if (STATE.markerSize < 20) {
                STATE.markerSize = 40;
            }

            elements.svgMarker.style.display = 'block';
            elements.svgMarker.style.width = `${STATE.markerSize}px`;
            elements.svgMarker.style.height = `${STATE.markerSize}px`;

            // åˆæœŸä½ç½®ï¼ˆå·¦ç«¯ã€è¡Œã®ä¸­å¤®ï¼‰
            STATE.markerX = 0;
            STATE.markerY = STATE.cellHeight / 2;
            STATE.targetX = STATE.markerX;
            STATE.targetY = STATE.markerY;

            console.log('Marker initialized:', {
                markerSize: STATE.markerSize,
                cellWidth: STATE.cellWidth,
                cellHeight: STATE.cellHeight,
                markerX: STATE.markerX,
                markerY: STATE.markerY
            });

            renderMarker();
        }

        // ==================================================
        // ãƒãƒ¼ã‚«ãƒ¼ç§»å‹•ï¼ˆVAMæº–æ‹ ï¼šæ»‘ã‚‰ã‹ãªãƒ”ã‚¯ã‚»ãƒ«å˜ä½ç§»å‹•ï¼‰
        // ==================================================

        /**
         * ãƒãƒ¼ã‚«ãƒ¼ã‚’æç”»ï¼ˆtransformã§é«˜é€Ÿæ›´æ–°ï¼‰
         */
        function renderMarker() {
            const halfSize = STATE.markerSize / 2;
            elements.svgMarker.style.transform = `translate(${STATE.markerX - halfSize}px, ${STATE.markerY - halfSize}px)`;
        }

        /**
         * ãƒãƒ¼ã‚«ãƒ¼ã‚’ç›®æ¨™ä½ç½®ã«æ»‘ã‚‰ã‹ã«ç§»å‹•ï¼ˆVAMæº–æ‹ ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
         * @param {number} targetX - ç›®æ¨™Xåº§æ¨™ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
         * @param {number} targetY - ç›®æ¨™Yåº§æ¨™ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
         * @param {boolean} animate - ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹ã‹ã©ã†ã‹
         */
        function moveMarkerTo(targetX, targetY, animate = true) {
            STATE.targetX = targetX;
            STATE.targetY = targetY;

            if (!animate) {
                // å³åº§ã«ç§»å‹•
                STATE.markerX = targetX;
                STATE.markerY = targetY;
                renderMarker();
                return;
            }

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
            if (!STATE.isAnimating) {
                STATE.isAnimating = true;
                animateMarker();
            }
        }

        /**
         * ãƒãƒ¼ã‚«ãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆVAMæº–æ‹ ï¼šease-outé¢¨è£œé–“ï¼‰
         * â˜… 60fpsã§æ»‘ã‚‰ã‹ã«ç§»å‹• â˜…
         */
        function animateMarker() {
            // ç›®æ¨™ã¨ã®è·é›¢
            const dx = STATE.targetX - STATE.markerX;
            const dy = STATE.targetY - STATE.markerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // ååˆ†è¿‘ã‘ã‚Œã°åœæ­¢
            if (distance < 0.5) {
                STATE.markerX = STATE.targetX;
                STATE.markerY = STATE.targetY;
                STATE.isAnimating = false;
                renderMarker();
                return;
            }

            // ease-outé¢¨ã®è£œé–“ï¼ˆVAMæº–æ‹ ï¼š12%ãšã¤è¿‘ã¥ãï¼‰
            const factor = 0.15;
            STATE.markerX += dx * factor;
            STATE.markerY += dy * factor;

            renderMarker();

            // æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ 
            STATE.animationId = requestAnimationFrame(animateMarker);
        }

        /**
         * å†ç”Ÿæ™‚åˆ»ã‹ã‚‰ãƒãƒ¼ã‚«ãƒ¼ä½ç½®ã‚’è¨ˆç®—ï¼ˆãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ï¼‰
         * â˜… VAMæº–æ‹ ï¼šcalculate_position_from_playback ã‚’ç§»æ¤ â˜…
         * Xè»¸: å·¦ç«¯(0)ã‹ã‚‰å³ç«¯(gridWidth)ã¾ã§é€£ç¶šç§»å‹•
         * Yè»¸: è¡Œã®ä¸­å¤®ã«å›ºå®š
         */
        function calculateMarkerPositionFromTime(currentTime) {
            if (STATE.totalCells === 0 || CONFIG.secondsPerCell <= 0 || STATE.cellWidth === 0) {
                return { x: 0, y: STATE.cellHeight / 2 || 0 };
            }

            // é€£ç¶šçš„ãªã‚»ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—ï¼ˆå°æ•°å€¤ï¼‰
            const continuousCellIndex = currentTime / CONFIG.secondsPerCell;

            // è¡Œç•ªå·ï¼ˆæ•´æ•°ï¼‰
            let currentRow = Math.floor(continuousCellIndex / CONFIG.columns);
            currentRow = Math.max(0, Math.min(currentRow, STATE.totalRows - 1));

            // è¡Œå†…ã®ä½ç½®ï¼ˆå°æ•°å€¤ã‚’ä¿æŒï¼‰
            let positionInRow = continuousCellIndex - (currentRow * CONFIG.columns);

            // Xåº§æ¨™: 0ï¼ˆå·¦ç«¯ï¼‰ã‹ã‚‰ gridWidthï¼ˆå³ç«¯ï¼‰ã¾ã§
            // positionInRow: 0 â†’ x=0, positionInRow: columns â†’ x=gridWidth
            const x = (positionInRow / CONFIG.columns) * STATE.gridWidth;

            // Yåº§æ¨™: è¡Œã®ä¸­å¤®
            const y = (currentRow + 0.5) * STATE.cellHeight;

            return {
                x: Math.max(0, Math.min(x, STATE.gridWidth)),
                y: Math.max(STATE.cellHeight / 2, Math.min(y, STATE.gridHeight - STATE.cellHeight / 2))
            };
        }

        /**
         * ã‚»ãƒ«å˜ä½ã§ã®ç§»å‹•ï¼ˆã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œç”¨ï¼‰
         */
        function moveToCell(col, row) {
            if (STATE.totalCells === 0) return;

            // å¢ƒç•Œãƒã‚§ãƒƒã‚¯
            col = Math.max(0, Math.min(col, CONFIG.columns - 1));
            row = Math.max(0, Math.min(row, STATE.totalRows - 1));

            // æœ€çµ‚ã‚»ãƒ«ã‚’è¶…ãˆãªã„ã‚ˆã†ã«ãƒã‚§ãƒƒã‚¯
            const cellIndex = row * CONFIG.columns + col;
            if (cellIndex >= STATE.totalCells) {
                const lastIndex = STATE.totalCells - 1;
                row = Math.floor(lastIndex / CONFIG.columns);
                col = lastIndex % CONFIG.columns;
            }

            // ã‚»ãƒ«åº§æ¨™ã‚’æ›´æ–°
            STATE.currentCellX = col;
            STATE.currentCellY = row;

            // ç›¸å¯¾åº§æ¨™ã‚‚æ›´æ–°ï¼ˆã‚»ãƒ«å·¦ç«¯åŸºæº–ï¼‰
            STATE.currentRelX = col / CONFIG.columns;
            STATE.currentRelY = (row + 0.5) / STATE.totalRows;

            // ãƒãƒ¼ã‚«ãƒ¼ã‚’ã‚»ãƒ«å·¦ç«¯ã«ç§»å‹•ï¼ˆYè»¸ã¯è¡Œä¸­å¤®ï¼‰
            const targetX = col * STATE.cellWidth;
            const targetY = (row + 0.5) * STATE.cellHeight;
            moveMarkerTo(targetX, targetY, true);

            updateDisplay();
            scrollToMarker();

            // å‹•ç”»ã‚’ã‚·ãƒ¼ã‚¯
            seekVideoWithContinuousMode();
        }

        /**
         * ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ã§ç§»å‹•ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ãƒ»å†ç”Ÿè¿½å¾“ç”¨ï¼‰
         * â˜… VAMæº–æ‹ : æ»‘ã‚‰ã‹ãªé€£ç¶šç§»å‹• â˜…
         */
        function moveToPixelPosition(x, y, animate = true) {
            if (STATE.totalCells === 0) return;

            // å¢ƒç•Œãƒã‚§ãƒƒã‚¯
            x = Math.max(0, Math.min(x, STATE.gridWidth));
            y = Math.max(0, Math.min(y, STATE.gridHeight));

            // ç›¸å¯¾åº§æ¨™ã«å¤‰æ›
            STATE.currentRelX = x / STATE.gridWidth;
            STATE.currentRelY = y / STATE.gridHeight;

            // ã‚»ãƒ«åº§æ¨™ã‚’è¨ˆç®—ï¼ˆè¡¨ç¤ºç”¨ï¼‰
            STATE.currentCellX = Math.floor(STATE.currentRelX * CONFIG.columns);
            STATE.currentCellY = Math.floor(STATE.currentRelY * STATE.totalRows);

            // å¢ƒç•Œãƒã‚§ãƒƒã‚¯
            STATE.currentCellX = Math.max(0, Math.min(STATE.currentCellX, CONFIG.columns - 1));
            STATE.currentCellY = Math.max(0, Math.min(STATE.currentCellY, STATE.totalRows - 1));

            // ãƒãƒ¼ã‚«ãƒ¼ã‚’ç§»å‹•
            moveMarkerTo(x, y, animate);

            updateDisplay();
        }

        function moveRelative(dx, dy) {
            // ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ç§»å‹•ãƒ•ãƒ©ã‚°ã‚’è¨­å®šï¼ˆè¿½å¾“ã‚’ä¸€æ™‚åœæ­¢ï¼‰
            setManualMoveFlag();
            moveToCell(STATE.currentCellX + dx, STATE.currentCellY + dy);
        }

        /**
         * ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ç§»å‹•ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
         */
        function setManualMoveFlag() {
            STATE.isManuallyMoved = true;
            if (STATE.manualMoveTimeout) {
                clearTimeout(STATE.manualMoveTimeout);
            }
            STATE.manualMoveTimeout = setTimeout(() => {
                STATE.isManuallyMoved = false;
            }, 500);
        }

        function scrollToMarker() {
            const container = elements.gridContainer;
            const markerY = STATE.targetY;
            const containerHeight = container.clientHeight;
            const scrollTop = container.scrollTop;

            if (markerY < scrollTop + STATE.cellHeight) {
                container.scrollTop = Math.max(0, markerY - STATE.cellHeight);
            } else if (markerY > scrollTop + containerHeight - STATE.cellHeight * 2) {
                container.scrollTop = markerY - containerHeight + STATE.cellHeight * 2;
            }
        }

        // ==================================================
        // å‹•ç”»åˆ¶å¾¡ï¼ˆVAMæº–æ‹ ï¼šXè»¸é€£ç¶šãƒ¢ãƒ¼ãƒ‰å¯¾å¿œï¼‰
        // ==================================================

        /**
         * Xè»¸é€£ç¶šãƒ¢ãƒ¼ãƒ‰ã§ã‚·ãƒ¼ã‚¯
         */
        function seekVideoWithContinuousMode() {
            if (!elements.videoPlayer.src || CONFIG.videoDuration <= 0) return;

            const timestamp = calculateXContinuousTimestamp(
                STATE.currentRelX,
                STATE.currentRelY,
                CONFIG.columns,
                STATE.totalRows,
                CONFIG.videoDuration,
                CONFIG.secondsPerCell
            );

            elements.videoPlayer.currentTime = timestamp;
        }

        function togglePlay() {
            if (elements.videoPlayer.paused) {
                elements.videoPlayer.play();
                elements.playBtn.textContent = 'â¸ åœæ­¢';
            } else {
                elements.videoPlayer.pause();
                elements.playBtn.textContent = 'â–¶ å†ç”Ÿ';
            }
        }

        // ==================================================
        // è¡¨ç¤ºæ›´æ–°ï¼ˆVAMæº–æ‹ ï¼šé«˜ç²¾åº¦ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¡¨ç¤ºï¼‰
        // ==================================================

        function updateDisplay() {
            // Xè»¸é€£ç¶šãƒ¢ãƒ¼ãƒ‰ã§æ­£ç¢ºãªã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’è¨ˆç®—
            const timestamp = calculateXContinuousTimestamp(
                STATE.currentRelX,
                STATE.currentRelY,
                CONFIG.columns,
                STATE.totalRows,
                CONFIG.videoDuration,
                CONFIG.secondsPerCell
            );

            // æ™‚é–“è¡¨ç¤º
            const timeStr = formatTime(timestamp);
            elements.currentTime.textContent = timeStr;
            elements.overlayTime.textContent = timeStr;

            // ã‚»ãƒ«æƒ…å ±ï¼ˆç›¸å¯¾åº§æ¨™ã‚‚è¡¨ç¤ºï¼‰
            elements.overlayCell.textContent = `(${STATE.currentCellX}, ${STATE.currentCellY})`;
        }

        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = seconds % 60;

            if (h > 0) {
                return `${h}:${String(m).padStart(2, '0')}:${s.toFixed(2).padStart(5, '0')}`;
            }
            return `${String(m).padStart(2, '0')}:${s.toFixed(2).padStart(5, '0')}`;
        }

        function formatTimeShort(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${String(s).padStart(2, '0')}`;
        }

        function showLoading(text) {
            elements.loadingText.textContent = text;
            elements.loadingOverlay.classList.add('visible');
        }

        function hideLoading() {
            elements.loadingOverlay.classList.remove('visible');
        }

        // ==================================================
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        // ==================================================

        function setupEventListeners() {
            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ
            document.addEventListener('keydown', handleKeyDown);

            // ã‚°ãƒªãƒƒãƒ‰ã§ã®ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œ
            elements.gridContainer.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // ã‚°ãƒªãƒƒãƒ‰ã§ã®ã‚¯ãƒªãƒƒã‚¯
            elements.thumbnailGrid.addEventListener('click', handleGridClick);

            // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
            elements.uploadDropzone.addEventListener('click', () => elements.fileInput.click());
            elements.fileInput.addEventListener('change', (e) => {
                if (e.target.files[0]) uploadVideo(e.target.files[0]);
            });

            // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
            elements.uploadDropzone.addEventListener('dragover', (e) => {
                e.preventDefault();
                elements.uploadDropzone.classList.add('dragover');
            });
            elements.uploadDropzone.addEventListener('dragleave', () => {
                elements.uploadDropzone.classList.remove('dragover');
            });
            elements.uploadDropzone.addEventListener('drop', (e) => {
                e.preventDefault();
                elements.uploadDropzone.classList.remove('dragover');
                if (e.dataTransfer.files[0]) uploadVideo(e.dataTransfer.files[0]);
            });

            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
            elements.playBtn.addEventListener('click', togglePlay);
            elements.regenerateBtn.addEventListener('click', generateThumbnails);

            // å‹•ç”»ã‚¤ãƒ™ãƒ³ãƒˆ
            elements.videoPlayer.addEventListener('timeupdate', handleVideoTimeUpdate);
            elements.videoPlayer.addEventListener('play', () => elements.playBtn.textContent = 'â¸ åœæ­¢');
            elements.videoPlayer.addEventListener('pause', () => elements.playBtn.textContent = 'â–¶ å†ç”Ÿ');
        }

        function handleKeyDown(e) {
            // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ä¸­ã¯ç„¡è¦–
            if (e.target.tagName === 'INPUT') return;

            // Tã‚­ãƒ¼: ãƒ„ãƒªãƒ¼ãƒ“ãƒ¥ãƒ¼åˆ‡æ›¿
            if (e.key === 't' || e.key === 'T') {
                elements.treePanel.classList.toggle('collapsed');
                e.preventDefault();
                return;
            }

            // ã‚¹ãƒšãƒ¼ã‚¹: å†ç”Ÿ/åœæ­¢
            if (e.key === ' ') {
                if (STATE.currentVideoId) togglePlay();
                e.preventDefault();
                return;
            }

            // æ–¹å‘ã‚­ãƒ¼: ãƒãƒ¼ã‚«ãƒ¼ç§»å‹•
            switch (e.key) {
                case 'ArrowUp':
                    moveRelative(0, -1);
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                    moveRelative(0, 1);
                    e.preventDefault();
                    break;
                case 'ArrowLeft':
                    moveRelative(-1, 0);
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    moveRelative(1, 0);
                    e.preventDefault();
                    break;
                case 'Home':
                    moveToCell(0, 0);
                    e.preventDefault();
                    break;
                case 'End':
                    if (STATE.totalCells > 0) {
                        const lastIndex = STATE.totalCells - 1;
                        moveToCell(lastIndex % CONFIG.columns, Math.floor(lastIndex / CONFIG.columns));
                    }
                    e.preventDefault();
                    break;
                case 'PageUp':
                    moveRelative(0, -10);
                    e.preventDefault();
                    break;
                case 'PageDown':
                    moveRelative(0, 10);
                    e.preventDefault();
                    break;
            }
        }

        /**
         * ãƒã‚¦ã‚¹ãƒ€ã‚¦ãƒ³: ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
         * â˜… VAMæº–æ‹ : ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ã§ç§»å‹• â˜…
         */
        function handleMouseDown(e) {
            if (e.target.closest('.thumbnail-grid')) {
                STATE.isDragging = true;
                setManualMoveFlag();

                // ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ã‚’è¨ˆç®—
                const pos = getMousePositionInGrid(e);
                moveToPixelPosition(pos.x, pos.y, false);  // å³åº§ã«ç§»å‹•
                seekVideoWithContinuousMode();
            }
        }

        /**
         * ãƒã‚¦ã‚¹ç§»å‹•: ãƒ‰ãƒ©ãƒƒã‚°ä¸­
         * â˜… VAMæº–æ‹ : ãƒ”ã‚¯ã‚»ãƒ«å˜ä½ã§æ»‘ã‚‰ã‹ã«è¿½å¾“ â˜…
         */
        function handleMouseMove(e) {
            if (STATE.isDragging) {
                const pos = getMousePositionInGrid(e);
                moveToPixelPosition(pos.x, pos.y, false);  // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯å³åº§ã«è¿½å¾“
                seekVideoWithContinuousMode();
            }
        }

        /**
         * ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—: ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†
         */
        function handleMouseUp() {
            if (STATE.isDragging) {
                STATE.isDragging = false;
                scrollToMarker();
            }
        }

        /**
         * ã‚°ãƒªãƒƒãƒ‰å†…ã®ãƒã‚¦ã‚¹ä½ç½®ã‚’å–å¾—ï¼ˆãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ï¼‰
         * ã‚°ãƒªãƒƒãƒ‰å…¨ä½“ã®åº§æ¨™ç³»ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«è¾¼ã¿ï¼‰ã§è¿”ã™
         */
        function getMousePositionInGrid(e) {
            const grid = elements.thumbnailGrid;
            const container = elements.gridContainer;

            // ã‚°ãƒªãƒƒãƒ‰ã®ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆä¸Šã®ä½ç½®
            const gridRect = grid.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();

            // ãƒã‚¦ã‚¹ä½ç½®ï¼ˆã‚³ãƒ³ãƒ†ãƒŠå†…ã®ç›¸å¯¾åº§æ¨™ï¼‰
            const mouseXInContainer = e.clientX - containerRect.left;
            const mouseYInContainer = e.clientY - containerRect.top;

            // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’åŠ ç®—ã—ã¦ã‚°ãƒªãƒƒãƒ‰å…¨ä½“ã§ã®åº§æ¨™ã‚’è¨ˆç®—
            const x = mouseXInContainer;
            const y = mouseYInContainer + container.scrollTop;

            return {
                x: Math.max(0, Math.min(x, STATE.gridWidth)),
                y: Math.max(0, Math.min(y, STATE.gridHeight))
            };
        }

        /**
         * ã‚°ãƒªãƒƒãƒ‰ã‚¯ãƒªãƒƒã‚¯: ãã®ä½ç½®ã«ç§»å‹•
         */
        function handleGridClick(e) {
            if (STATE.isDragging) return;

            setManualMoveFlag();
            const pos = getMousePositionInGrid(e);
            moveToPixelPosition(pos.x, pos.y, true);  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãã§ç§»å‹•
            seekVideoWithContinuousMode();
        }

        /**
         * å‹•ç”»å†ç”Ÿè¿½å¾“ï¼ˆVAMæº–æ‹ ï¼‰
         * â˜… å†ç”Ÿæ™‚åˆ»ã«åˆã‚ã›ã¦ãƒãƒ¼ã‚«ãƒ¼ãŒæ»‘ã‚‰ã‹ã«é€£ç¶šç§»å‹• â˜…
         */
        function handleVideoTimeUpdate() {
            const currentTime = elements.videoPlayer.currentTime;

            // ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ç§»å‹•ä¸­ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯è¿½å¾“ã—ãªã„
            if (STATE.isManuallyMoved || STATE.isDragging) {
                elements.currentTime.textContent = formatTime(currentTime);
                return;
            }

            // ã‚°ãƒªãƒƒãƒ‰ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’æ›´æ–°
            if (STATE.totalCells > 0 && STATE.cellWidth > 0) {
                // å†ç”Ÿä½ç½®ã‹ã‚‰ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ã‚’è¨ˆç®—ï¼ˆæ»‘ã‚‰ã‹ãªé€£ç¶šç§»å‹•ï¼‰
                const pos = calculateMarkerPositionFromTime(currentTime);

                // ãƒãƒ¼ã‚«ãƒ¼ã‚’æ»‘ã‚‰ã‹ã«ç§»å‹•ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãï¼‰
                moveMarkerTo(pos.x, pos.y, true);

                // ã‚»ãƒ«åº§æ¨™ã‚’æ›´æ–°ï¼ˆè¡¨ç¤ºç”¨ï¼‰
                const continuousCellIndex = currentTime / CONFIG.secondsPerCell;
                const currentRow = Math.floor(continuousCellIndex / CONFIG.columns);
                const positionInRow = continuousCellIndex - (currentRow * CONFIG.columns);

                STATE.currentCellX = Math.floor(positionInRow);
                STATE.currentCellY = Math.min(currentRow, STATE.totalRows - 1);
                STATE.currentRelX = positionInRow / CONFIG.columns;
                STATE.currentRelY = (currentRow + 0.5) / STATE.totalRows;

                // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼ˆè¡ŒãŒå¤‰ã‚ã£ãŸæ™‚ã®ã¿ï¼‰
                const newRow = Math.floor(STATE.targetY / STATE.cellHeight);
                if (newRow !== Math.floor(STATE.markerY / STATE.cellHeight)) {
                    scrollToMarker();
                }
            }

            // æ™‚åˆ»è¡¨ç¤ºã‚’æ›´æ–°
            elements.currentTime.textContent = formatTime(currentTime);
            elements.overlayTime.textContent = formatTime(currentTime);
            elements.overlayCell.textContent = `(${STATE.currentCellX}, ${STATE.currentCellY})`;
        }

        // ==================================================
        // APIæ¥ç¶š
        // ==================================================

        async function checkApiConnection() {
            try {
                const response = await fetch(`${API_BASE}/api/health`);
                if (response.ok) {
                    STATE.isApiConnected = true;
                    elements.apiStatus.textContent = 'API: æ¥ç¶šOK';
                    elements.apiStatus.style.color = '#4caf50';
                    return;
                }
            } catch (e) {
                console.log('API not available');
            }
            STATE.isApiConnected = false;
            elements.apiStatus.textContent = 'API: æœªæ¥ç¶š';
            elements.apiStatus.style.color = '#f44336';
        }

        // ==================================================
        // èµ·å‹•
        // ==================================================

        init();
        setInterval(checkApiConnection, 10000);
    </script>
</body>
</html>
